{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Dataview is a live index and query engine over your knowledge base. You can associate data (like tags, dates, snippets, numbers, and so on) with your markdown pages, and then query (like filter, sort, transform) this data. This is a simple but powerful idea: Track sleep schedules and habits by recording them in daily notes, and automatically create weekly tables of your sleep schedule. Automatically collect links to books in your notes, and render them all sorted by rating. Automatically collect pages annotated with a given date, showing them in your daily note or elsewhere. Find pages with no tags for follow-up, or show pretty views of specifically-tagged pages. Create dynamic views which show upcoming birthdays or events, annotated with notes. Dataview is highly generic and high performance, scaling up to hundreds of thousands of annotated notes without issue. If the built in query language is insufficient for your purpose, you can run arbitrary JavaScript against the dataview API . Basic Usage Dataview has two major components: annotation and querying . Each operates largely independently and are described below. Annotation The dataview index is responsible for constantly parsing markdown files and other metadata in your vault, creating an in-memory index which allows for fast queries over your data. Annotation is done at the markdown page , section , and task level, where you can either use: Frontmatter , a common Markdown extension which allows for adding arbitrary YAML at the top of a document): --- alias : \"document\" last-reviewed : 2021-08-17 thoughts : rating : 8 reviewable : false --- Inline Fields , a Dataview-specific way to provide metadata in an intuitive Key:: Value syntax: # Markdown Page Basic Field:: Value **Bold Field** :: Nice! - [ ] I am a task with [metadata::value]! - [X] I am another task with completed::2020-09-15 You can combine both methods if desired. Dataview also adds a significant number of \"implicit\" fields, like file.name for the file name, file.size for the size, and so on; you can find more details in the data annotation documentation . Querying Once you have some pages that you've annotated, all that's left to do is query them to create dynamic table, list, or JavaScript views. There are four ways to do this: Dataview Query Language (DQL) : A pipeline-based, vaguely SQL-looking expression language which can support basic use cases. See the documentation for details. ```dataview TABLE file.name AS \"File\", rating AS \"Rating\" FROM #book ``` Inline Expressions : DQL expressions which you can embed directly inside markdown and which will be evaluated in preview mode. See the documentation for allowable queries. We are on page `= this.file.name` . DataviewJS : A high-powered JavaScript API which gives full access to the Dataview index and some convienent rendering utilities. Highly recommended if you know JavaScript, since this is far more powerful than the query language. Check the documentation for more details. ```dataviewjs dv.taskList(dv.pages().file.tasks.where(t => !t.completed)); ``` Inline JS Expressions : The JavaScript equivalent to inline expressions, which allow you to execute arbitary JS inline: This page was last modified at `$= dv.current().file.mtime` .","title":"Overview"},{"location":"#overview","text":"Dataview is a live index and query engine over your knowledge base. You can associate data (like tags, dates, snippets, numbers, and so on) with your markdown pages, and then query (like filter, sort, transform) this data. This is a simple but powerful idea: Track sleep schedules and habits by recording them in daily notes, and automatically create weekly tables of your sleep schedule. Automatically collect links to books in your notes, and render them all sorted by rating. Automatically collect pages annotated with a given date, showing them in your daily note or elsewhere. Find pages with no tags for follow-up, or show pretty views of specifically-tagged pages. Create dynamic views which show upcoming birthdays or events, annotated with notes. Dataview is highly generic and high performance, scaling up to hundreds of thousands of annotated notes without issue. If the built in query language is insufficient for your purpose, you can run arbitrary JavaScript against the dataview API .","title":"Overview"},{"location":"#basic-usage","text":"Dataview has two major components: annotation and querying . Each operates largely independently and are described below.","title":"Basic Usage"},{"location":"#annotation","text":"The dataview index is responsible for constantly parsing markdown files and other metadata in your vault, creating an in-memory index which allows for fast queries over your data. Annotation is done at the markdown page , section , and task level, where you can either use: Frontmatter , a common Markdown extension which allows for adding arbitrary YAML at the top of a document): --- alias : \"document\" last-reviewed : 2021-08-17 thoughts : rating : 8 reviewable : false --- Inline Fields , a Dataview-specific way to provide metadata in an intuitive Key:: Value syntax: # Markdown Page Basic Field:: Value **Bold Field** :: Nice! - [ ] I am a task with [metadata::value]! - [X] I am another task with completed::2020-09-15 You can combine both methods if desired. Dataview also adds a significant number of \"implicit\" fields, like file.name for the file name, file.size for the size, and so on; you can find more details in the data annotation documentation .","title":"Annotation"},{"location":"#querying","text":"Once you have some pages that you've annotated, all that's left to do is query them to create dynamic table, list, or JavaScript views. There are four ways to do this: Dataview Query Language (DQL) : A pipeline-based, vaguely SQL-looking expression language which can support basic use cases. See the documentation for details. ```dataview TABLE file.name AS \"File\", rating AS \"Rating\" FROM #book ``` Inline Expressions : DQL expressions which you can embed directly inside markdown and which will be evaluated in preview mode. See the documentation for allowable queries. We are on page `= this.file.name` . DataviewJS : A high-powered JavaScript API which gives full access to the Dataview index and some convienent rendering utilities. Highly recommended if you know JavaScript, since this is far more powerful than the query language. Check the documentation for more details. ```dataviewjs dv.taskList(dv.pages().file.tasks.where(t => !t.completed)); ``` Inline JS Expressions : The JavaScript equivalent to inline expressions, which allow you to execute arbitary JS inline: This page was last modified at `$= dv.current().file.mtime` .","title":"Querying"},{"location":"changelog/","text":"0.4.19 Bugfix release which corrects emoji parsing & localization issues. Add DataArray#into , which lets you index into objects without flattening. Renamed 'header' to 'section' in task metadata; 'header' will remain around for a few major releases to let people naturally migrate. Fix #487: You no longer need spaces around '*' in expressions. Fix #559: Fix unicode issues in variable canonicalization which was causing problems with non-Latin inline field keys. Duration Parsing You can now include multiple units in durations: dur(8 minutes, 4 seconds) or dur(2yr8mo12d) . You can separate durations by commas, or use the abbreviated syntax with/without spaces. 0.4.18 Bugfix release which fixes bad inline field highlighting if '[' and '(' are mixed on the same line in particular orders. 0.4.17 Minor feature release to patch up more implementation holes. Single File Queries You can now query from a specific file (instead of just folders and tags) by specifying the full file path: TASK FROM \"dataview/Test\" ... This is primarily useful for task queries, but will soon be useful for section and object queries in the near future as well. Better Inline Field Highlighting The CSS for inline field highlighting has been fixed and some compatibility issues improved, so it should work on all themes now instead of only a few. dv.el() DataviewJS now has dv.el() , which is like existing functions like dv.paragraph and dv.span but can create any HTML element type; for example: dv . el ( \"b\" , \"Text!\" ); dv . el ( \"i\" , 18 ); 0.4.16 Small performance release which substantially reduces the impact Dataview has on vault loading times (by spreading out file loading). The Dataview Index is now also eagerly initialized, so plugin consumers of the API can immediately start using it instead of waiting for the dataview:api-ready event. 0.4.15 A simple fix for #537 which properly 'awaits' value rendering in dv.view() . Fixes issues with values rendering out of order. 0.4.14 Small bugfix release. Fixes inline field evaluation when using the new fancy highlighting. You can now configure whether task links should show up at the beginning or end of the task (or just disable them) in the \"Task Link Location\" setting. Most setting updates will immediately be applied to existing Dataviews. 0.4.13 Bugfix release which adds fancy rendering to inline-inline fields and includes a few bugfixes. Pretty Inline Fields Inline fields of the form [key:: value] will now be rendered with fancy new HTML! By default, they are rendered with both the key and value. You can only render the value using parenthesis instead: (key:: value) . You can disable this feature in the configuration. Full-line inline fields (that Dataview has supported for a long time) will gain similar rendering support soon; in the meanwhile, give the new syntax a try! Task Linking Tasks now render with a link to the page/section that they are defined in, making GROUP BY and custom task editing easier to do: A Task. \ud83d\udd17 Another Task. \ud83d\udd17 Some Random Subtask. \ud83d\udd17 You can configure the symbol for the link or disable it alltogether. Improving DataviewJS Posture I am currently actively looking into improving DataviewJS sandboxing and general security posture. As a first small step in this, I have made DataviewJS opt-in instead of opt-out, and added a separate control for Inline DataviewJS. You may need to re-enable it in your settings if you use it. More improvements and better JavaScript sandboxing will follow. 0.4.12-hotfix1 Re-release of 0.4.12 that fixes an important indexing issue. Fix #505: Use completion instead of completed when setting task completion time. Fix #509: Add startswith / endswith string functions. Fix #488: Add padleft and padright , and string . Fix #506, #512: Fix date comparisons due to a bizarre date zone issue. 0.4.12 Bugfix release following up 0.4.11 which includes a few minor function additions. Fix #512: Strange zone issue causing dates to not be equal. Fix #506: Same as #512. Fix #488: Add padleft / padright functions. Fix #509: Add startswith and endswith functions. Fix #505: Correctly read completion dates for tasks from completion . This release also includes improved testing thanks to mocking Obsidian plugin APIs! 0.4.11 Fixes task behavior and adds \"truly inline\" fields! Improved Task Behavior Task queries are now much improved from their primitive foundations - you can now filter, sort, and group them! The FROM block is still page-based, sadly, though you can simply use WHERE instead if desired. For example, you can now access task fields like text , line , or completed : TASK WHERE contains(text, \"#tag\") WHERE !completed GROUP BY file.folder The full list of all available task metadata can be found here ; tasks include all the information needed to uniquely identify them, and automatically inherit all of the metadata from their parent file as well (so you can access file.name , for example). You can also annotate tasks with inline fields, as described in the section below. There is some additional UX work to be done - primarily on more easily allowing you to navigate to where the task is defined, as well as render tasks in views other than the TASK view. The semantics of how grouping works (to make it more intuitive/useful than it currently is) will likely also be revisited. Inline Inline Fields Early support for truly inline fields have been added, where you can add metadata in the middle of a sentence. It looks similar to existing inline field syntax, but with brackets or parenthesis: I would rate this a [rating:: 6]. It was (thoughts:: acceptable). Improved rendering for all inline fields is coming in an unpcoming update to improve the visual look of these inline fields. Issues Fix #496: Fix task SORT functionality to do something. Fix #492: Tasks now properly annotated with parent file information. Fix #498: Fix task checking/unchecking logic (which broke due to a change in the task regex...). Initial Start of the automatic changelog.","title":"Changelog"},{"location":"changelog/#0419","text":"Bugfix release which corrects emoji parsing & localization issues. Add DataArray#into , which lets you index into objects without flattening. Renamed 'header' to 'section' in task metadata; 'header' will remain around for a few major releases to let people naturally migrate. Fix #487: You no longer need spaces around '*' in expressions. Fix #559: Fix unicode issues in variable canonicalization which was causing problems with non-Latin inline field keys.","title":"0.4.19"},{"location":"changelog/#duration-parsing","text":"You can now include multiple units in durations: dur(8 minutes, 4 seconds) or dur(2yr8mo12d) . You can separate durations by commas, or use the abbreviated syntax with/without spaces.","title":"Duration Parsing"},{"location":"changelog/#0418","text":"Bugfix release which fixes bad inline field highlighting if '[' and '(' are mixed on the same line in particular orders.","title":"0.4.18"},{"location":"changelog/#0417","text":"Minor feature release to patch up more implementation holes.","title":"0.4.17"},{"location":"changelog/#single-file-queries","text":"You can now query from a specific file (instead of just folders and tags) by specifying the full file path: TASK FROM \"dataview/Test\" ... This is primarily useful for task queries, but will soon be useful for section and object queries in the near future as well.","title":"Single File Queries"},{"location":"changelog/#better-inline-field-highlighting","text":"The CSS for inline field highlighting has been fixed and some compatibility issues improved, so it should work on all themes now instead of only a few.","title":"Better Inline Field Highlighting"},{"location":"changelog/#dvel","text":"DataviewJS now has dv.el() , which is like existing functions like dv.paragraph and dv.span but can create any HTML element type; for example: dv . el ( \"b\" , \"Text!\" ); dv . el ( \"i\" , 18 );","title":"dv.el()"},{"location":"changelog/#0416","text":"Small performance release which substantially reduces the impact Dataview has on vault loading times (by spreading out file loading). The Dataview Index is now also eagerly initialized, so plugin consumers of the API can immediately start using it instead of waiting for the dataview:api-ready event.","title":"0.4.16"},{"location":"changelog/#0415","text":"A simple fix for #537 which properly 'awaits' value rendering in dv.view() . Fixes issues with values rendering out of order.","title":"0.4.15"},{"location":"changelog/#0414","text":"Small bugfix release. Fixes inline field evaluation when using the new fancy highlighting. You can now configure whether task links should show up at the beginning or end of the task (or just disable them) in the \"Task Link Location\" setting. Most setting updates will immediately be applied to existing Dataviews.","title":"0.4.14"},{"location":"changelog/#0413","text":"Bugfix release which adds fancy rendering to inline-inline fields and includes a few bugfixes.","title":"0.4.13"},{"location":"changelog/#pretty-inline-fields","text":"Inline fields of the form [key:: value] will now be rendered with fancy new HTML! By default, they are rendered with both the key and value. You can only render the value using parenthesis instead: (key:: value) . You can disable this feature in the configuration. Full-line inline fields (that Dataview has supported for a long time) will gain similar rendering support soon; in the meanwhile, give the new syntax a try!","title":"Pretty Inline Fields"},{"location":"changelog/#task-linking","text":"Tasks now render with a link to the page/section that they are defined in, making GROUP BY and custom task editing easier to do: A Task. \ud83d\udd17 Another Task. \ud83d\udd17 Some Random Subtask. \ud83d\udd17 You can configure the symbol for the link or disable it alltogether.","title":"Task Linking"},{"location":"changelog/#improving-dataviewjs-posture","text":"I am currently actively looking into improving DataviewJS sandboxing and general security posture. As a first small step in this, I have made DataviewJS opt-in instead of opt-out, and added a separate control for Inline DataviewJS. You may need to re-enable it in your settings if you use it. More improvements and better JavaScript sandboxing will follow.","title":"Improving DataviewJS Posture"},{"location":"changelog/#0412-hotfix1","text":"Re-release of 0.4.12 that fixes an important indexing issue. Fix #505: Use completion instead of completed when setting task completion time. Fix #509: Add startswith / endswith string functions. Fix #488: Add padleft and padright , and string . Fix #506, #512: Fix date comparisons due to a bizarre date zone issue.","title":"0.4.12-hotfix1"},{"location":"changelog/#0412","text":"Bugfix release following up 0.4.11 which includes a few minor function additions. Fix #512: Strange zone issue causing dates to not be equal. Fix #506: Same as #512. Fix #488: Add padleft / padright functions. Fix #509: Add startswith and endswith functions. Fix #505: Correctly read completion dates for tasks from completion . This release also includes improved testing thanks to mocking Obsidian plugin APIs!","title":"0.4.12"},{"location":"changelog/#0411","text":"Fixes task behavior and adds \"truly inline\" fields!","title":"0.4.11"},{"location":"changelog/#improved-task-behavior","text":"Task queries are now much improved from their primitive foundations - you can now filter, sort, and group them! The FROM block is still page-based, sadly, though you can simply use WHERE instead if desired. For example, you can now access task fields like text , line , or completed : TASK WHERE contains(text, \"#tag\") WHERE !completed GROUP BY file.folder The full list of all available task metadata can be found here ; tasks include all the information needed to uniquely identify them, and automatically inherit all of the metadata from their parent file as well (so you can access file.name , for example). You can also annotate tasks with inline fields, as described in the section below. There is some additional UX work to be done - primarily on more easily allowing you to navigate to where the task is defined, as well as render tasks in views other than the TASK view. The semantics of how grouping works (to make it more intuitive/useful than it currently is) will likely also be revisited.","title":"Improved Task Behavior"},{"location":"changelog/#inline-inline-fields","text":"Early support for truly inline fields have been added, where you can add metadata in the middle of a sentence. It looks similar to existing inline field syntax, but with brackets or parenthesis: I would rate this a [rating:: 6]. It was (thoughts:: acceptable). Improved rendering for all inline fields is coming in an unpcoming update to improve the visual look of these inline fields.","title":"Inline Inline Fields"},{"location":"changelog/#issues","text":"Fix #496: Fix task SORT functionality to do something. Fix #492: Tasks now properly annotated with parent file information. Fix #498: Fix task checking/unchecking logic (which broke due to a change in the task regex...).","title":"Issues"},{"location":"changelog/#initial","text":"Start of the automatic changelog.","title":"Initial"},{"location":"data-annotation/","text":"Data Annotation Dataview is a data index first and foremost, so it supports relatively rich ways of adding metadata to your knowledge base. Dataview tracks information at the markdown page and markdown task levels, where each page/task can have an arbitrary amount of complex (numbers, objects, lists) fields associated with it. Each field is a named value with a certain type (like \"number\" or \"text\"). Pages You can add fields to a markdown page in three different ways: Frontmatter : Frontmatter is a common Markdown extension which allows for YAML metadata to be added to the top of a page. All YAML fields will be available as Dataview fields: --- alias : \"document\" last-reviewed : 2021-08-17 thoughts : rating : 8 reviewable : false --- Inline Fields : For those wanting a more natural-looking annotation, Dataview supports \"inline\" fields, which offer a simple Key:: Value syntax that you can embed directly in your file: # Markdown Page Basic Field:: Value **Bold Field** :: Nice! If you want to embed metadata inside sentences, or multiple fields on the same line, you can use the bracket syntax: I would rate this a [rating:: 9]! It was [mood:: acceptable]. Implicit : Dataview annotates pages with a large amount of metadata automatically, like the day the file was created ( file.cday ), any associated dates ( file.day ), links in the file ( file.outlinks ), tags ( file.tags ), and so on. A simple Markdown page which includes both user-defined ways to add metadata: --- duration: 4 hours reviewed: false --- # Movie X **Thoughts** :: It was decent. **Rating** :: 6 Implicit Fields Dataview automatically adds a large amount of metadata to each page: file.name : The file title (a string). file.folder : The path of the folder this file belongs to. file.path : The full file path (a string). file.link : A link to the file (a link). file.size : The size (in bytes) of the file (a number). file.ctime : The date that the file was created (a date + time). file.cday : The date that the file was created (just a date). file.mtime : The date that the file was last modified (a date + time). file.mday : The date that the file was last modified (just a date). file.tags : An array of all unique tags in the note. Subtags are broken down by each level, so #Tag/1/A will be stored in the array as [#Tag, #Tag/1, #Tag/1/A] . file.etags : An array of all explicit tags in the note; unlike file.tags , does not include subtags. file.inlinks : An array of all incoming links to this file. file.outlinks : An array of all outgoing links from this file. file.aliases : An array of all aliases for the note. file.tasks : An array of all tasks (I.e., - [ ] blah blah blah ) in this file. If the file has a date inside its title (of form yyyy-mm-dd or yyyymmdd ), or has a Date field/inline field, it also has the following attributes: file.day : An explicit date associated with the file. Tasks You can also annotate your tasks (I.e., lines of the form - [ ] blah blah blah ) with metadata using inline field syntax: - [ ] Hello, this is some [metadata:: value]! - [X] I finished this on [completion::2021-08-15]. Field Shorthands For supporting \"common use cases\", Dataview understands a few shorthands for common data you may want to annotate task with: Syntax Due Date: \ud83d\uddd3\ufe0fYYYY-MM-DD Completed Date: \u2705YYYY-MM-DD Created Date: \u2795YYYY-MM-DD Example Do this saturday \ud83d\uddd3\ufe0f2021-08-29. Completed last saturday \u27052021-08-22. I made this on \u27951990-06-14. Note that, if you do not like emojis, you can still annotate these fields textually ( [due:: ] , [created:: ] , [completion:: ] ). Implicit Fields As with pages, Dataview adds a number of implicit fields to each task: Tasks inherit all fields from their parent page - so if you have a rating field in your page, you can also access it on your task. completed : Whether or not this specific task has been completed. fullyCompleted : Whether or not this task and all of its subtasks are completed. text : The text of this task. line : The line this task shows up on. path : The full path of the file this task is in. section : A link to the section this task is contained in. link : A link to the closest linkable block near this task; useful for making links which go to the task. subtasks : Any subtasks of this task. real : If true, this is a real task; otherwise, it is a list element above/below a task. completion : The date a task was completed. If not annotated, will default to file modified time. due : The date a task is due, if it has one. created : The date a task was created. If not annotated, defaults to file creation time. annotated : True if the task has any custom annotations, and false otherwise. Field Types All fields in dataview have a type , which determines how dataview will render, sort, and operate on that field. Dataview understands several distinct field types to cover common use cases: Text : The default catch-all. If a field doesn't match a more specific type, it is just plain text. Example:: This is some normal text. Number : Numbers like '6' and '3.6'. Example:: 6 Example:: 2.4 Example:: -80 Boolean : true/false, as the programming concept. Example:: true Example:: false Date : ISO8601 dates of the general form YYYY-MM[-DDTHH:mm:ss.nnn+ZZ] . Everything after the month is optional. Example:: 2021-04-18 Example:: 2021-04-18T04:19:35.000 Example:: 2021-04-18T04:19:35.000+06:30 Duration : Durations of the form <time> <unit> , like 6 hours or 4 minutes . Common english abbreviations like 6hrs or 2m are accepted. You can specify multiple units using an optional comma separator: 6 hours, 4 minutes or 6hr4min . Example:: 7 hours Example:: 4min Example:: 16 days Example:: 9 years, 8 months, 4 days, 16 hours, 2 minutes Example:: 9 yrs 8 min Link : Plain Obsidian links like [[Page]] or [[Page|Page Display]] . If you reference a link in frontmatter, you need to quote it, as so: key: \"[[Link]]\" . This is default Obsidian-supported behavior. Example:: [[A Page]] Example:: [[Some Other Page|Render Text]] List : Lists of other dataview fields. In YAML, these are defined as normal YAML lists; for inline fields, they are just comma-separated lists. Example:: 1, 2, 3 Example:: \"yes\", \"or\", \"no\" Object : A map of name to dataview field. These can only be defined in YAML frontmatter, using the normal YAML object syntax: field: value1: 1 value2: 2 ...","title":"Data Annotation"},{"location":"data-annotation/#data-annotation","text":"Dataview is a data index first and foremost, so it supports relatively rich ways of adding metadata to your knowledge base. Dataview tracks information at the markdown page and markdown task levels, where each page/task can have an arbitrary amount of complex (numbers, objects, lists) fields associated with it. Each field is a named value with a certain type (like \"number\" or \"text\").","title":"Data Annotation"},{"location":"data-annotation/#pages","text":"You can add fields to a markdown page in three different ways: Frontmatter : Frontmatter is a common Markdown extension which allows for YAML metadata to be added to the top of a page. All YAML fields will be available as Dataview fields: --- alias : \"document\" last-reviewed : 2021-08-17 thoughts : rating : 8 reviewable : false --- Inline Fields : For those wanting a more natural-looking annotation, Dataview supports \"inline\" fields, which offer a simple Key:: Value syntax that you can embed directly in your file: # Markdown Page Basic Field:: Value **Bold Field** :: Nice! If you want to embed metadata inside sentences, or multiple fields on the same line, you can use the bracket syntax: I would rate this a [rating:: 9]! It was [mood:: acceptable]. Implicit : Dataview annotates pages with a large amount of metadata automatically, like the day the file was created ( file.cday ), any associated dates ( file.day ), links in the file ( file.outlinks ), tags ( file.tags ), and so on. A simple Markdown page which includes both user-defined ways to add metadata: --- duration: 4 hours reviewed: false --- # Movie X **Thoughts** :: It was decent. **Rating** :: 6","title":"Pages"},{"location":"data-annotation/#implicit-fields","text":"Dataview automatically adds a large amount of metadata to each page: file.name : The file title (a string). file.folder : The path of the folder this file belongs to. file.path : The full file path (a string). file.link : A link to the file (a link). file.size : The size (in bytes) of the file (a number). file.ctime : The date that the file was created (a date + time). file.cday : The date that the file was created (just a date). file.mtime : The date that the file was last modified (a date + time). file.mday : The date that the file was last modified (just a date). file.tags : An array of all unique tags in the note. Subtags are broken down by each level, so #Tag/1/A will be stored in the array as [#Tag, #Tag/1, #Tag/1/A] . file.etags : An array of all explicit tags in the note; unlike file.tags , does not include subtags. file.inlinks : An array of all incoming links to this file. file.outlinks : An array of all outgoing links from this file. file.aliases : An array of all aliases for the note. file.tasks : An array of all tasks (I.e., - [ ] blah blah blah ) in this file. If the file has a date inside its title (of form yyyy-mm-dd or yyyymmdd ), or has a Date field/inline field, it also has the following attributes: file.day : An explicit date associated with the file.","title":"Implicit Fields"},{"location":"data-annotation/#tasks","text":"You can also annotate your tasks (I.e., lines of the form - [ ] blah blah blah ) with metadata using inline field syntax: - [ ] Hello, this is some [metadata:: value]! - [X] I finished this on [completion::2021-08-15].","title":"Tasks"},{"location":"data-annotation/#field-shorthands","text":"For supporting \"common use cases\", Dataview understands a few shorthands for common data you may want to annotate task with: Syntax Due Date: \ud83d\uddd3\ufe0fYYYY-MM-DD Completed Date: \u2705YYYY-MM-DD Created Date: \u2795YYYY-MM-DD Example Do this saturday \ud83d\uddd3\ufe0f2021-08-29. Completed last saturday \u27052021-08-22. I made this on \u27951990-06-14. Note that, if you do not like emojis, you can still annotate these fields textually ( [due:: ] , [created:: ] , [completion:: ] ).","title":"Field Shorthands"},{"location":"data-annotation/#implicit-fields_1","text":"As with pages, Dataview adds a number of implicit fields to each task: Tasks inherit all fields from their parent page - so if you have a rating field in your page, you can also access it on your task. completed : Whether or not this specific task has been completed. fullyCompleted : Whether or not this task and all of its subtasks are completed. text : The text of this task. line : The line this task shows up on. path : The full path of the file this task is in. section : A link to the section this task is contained in. link : A link to the closest linkable block near this task; useful for making links which go to the task. subtasks : Any subtasks of this task. real : If true, this is a real task; otherwise, it is a list element above/below a task. completion : The date a task was completed. If not annotated, will default to file modified time. due : The date a task is due, if it has one. created : The date a task was created. If not annotated, defaults to file creation time. annotated : True if the task has any custom annotations, and false otherwise.","title":"Implicit Fields"},{"location":"data-annotation/#field-types","text":"All fields in dataview have a type , which determines how dataview will render, sort, and operate on that field. Dataview understands several distinct field types to cover common use cases: Text : The default catch-all. If a field doesn't match a more specific type, it is just plain text. Example:: This is some normal text. Number : Numbers like '6' and '3.6'. Example:: 6 Example:: 2.4 Example:: -80 Boolean : true/false, as the programming concept. Example:: true Example:: false Date : ISO8601 dates of the general form YYYY-MM[-DDTHH:mm:ss.nnn+ZZ] . Everything after the month is optional. Example:: 2021-04-18 Example:: 2021-04-18T04:19:35.000 Example:: 2021-04-18T04:19:35.000+06:30 Duration : Durations of the form <time> <unit> , like 6 hours or 4 minutes . Common english abbreviations like 6hrs or 2m are accepted. You can specify multiple units using an optional comma separator: 6 hours, 4 minutes or 6hr4min . Example:: 7 hours Example:: 4min Example:: 16 days Example:: 9 years, 8 months, 4 days, 16 hours, 2 minutes Example:: 9 yrs 8 min Link : Plain Obsidian links like [[Page]] or [[Page|Page Display]] . If you reference a link in frontmatter, you need to quote it, as so: key: \"[[Link]]\" . This is default Obsidian-supported behavior. Example:: [[A Page]] Example:: [[Some Other Page|Render Text]] List : Lists of other dataview fields. In YAML, these are defined as normal YAML lists; for inline fields, they are just comma-separated lists. Example:: 1, 2, 3 Example:: \"yes\", \"or\", \"no\" Object : A map of name to dataview field. These can only be defined in YAML frontmatter, using the normal YAML object syntax: field: value1: 1 value2: 2 ...","title":"Field Types"},{"location":"data-queries/","text":"Creating Queries Once you've added useful data to relevant pages, you'll want to actually display it somewhere or operate on it. Dataview allows this in four different ways, all of which are written in codeblocks directly in your Markdown and live-reloaded when your vault changes. Dataview Query Language (DQL) The dataview query language is a simplistic, SQL-like language for quickly creating views. It supports basic arithmetic and comparison operations, and is good for basic applications. You create dataview queries using dataview -annotated codeblocks: ```dataview TABLE rating AS \"Rating\", summary AS \"Summary\" FROM #games SORT rating DESC ``` The details of how to write a query are explained in the query language documentation ; if you learn better by example, take a look at the query examples . Inline DQL The query language also provides inline queries, which allow you to embed single values directly inside a page - for example, todays date via = date(today) , or a field from another page via = [[Page]].value . You create inline queries using inline codeblocks: `= this.file.name` Inline DQL expressions are written using the query language expression language . You can configure inline queries to use a different prefix (like dv: or ~ ) in the Dataview settings. Dataview JS The dataview JavaScript API gives you the full power of JavaScript and provides a DSL for pulling Dataview data and executing queries, allowing you to create arbitrarily complex queries and views. Similar to the query language, you create Dataview JS blocks via a dataviewjs -annotated codeblock: ``` dataviewjs let pages = dv . pages ( \"#books and -#books/finished\" ). where ( b => b . rating >= 7 ); for ( let group of pages . groupBy ( b => b . genre )) { dv . header ( group . key ); dv . list ( group . rows . file . name ); } ``` Inside of a JS dataview block, you have access to the full dataview API via the dv variable. For an explanation of what you can do with it, see the API documentation , or the API examples . Inline Dataview JS Similar to the query language, you can write JS inline queries, which let you embed a computed JS value directly. You create JS inline queries via inline code blocks: `$= dv.current().file.mtime` In inline DataviewJS, you have access to the dv variable, as in dataviewjs codeblocks, and can make all of the same calls. The result should be something which evaluates to a JavaScript value, which Dataview will automatically render appropriately.","title":"Data Querying"},{"location":"data-queries/#creating-queries","text":"Once you've added useful data to relevant pages, you'll want to actually display it somewhere or operate on it. Dataview allows this in four different ways, all of which are written in codeblocks directly in your Markdown and live-reloaded when your vault changes.","title":"Creating Queries"},{"location":"data-queries/#dataview-query-language-dql","text":"The dataview query language is a simplistic, SQL-like language for quickly creating views. It supports basic arithmetic and comparison operations, and is good for basic applications. You create dataview queries using dataview -annotated codeblocks: ```dataview TABLE rating AS \"Rating\", summary AS \"Summary\" FROM #games SORT rating DESC ``` The details of how to write a query are explained in the query language documentation ; if you learn better by example, take a look at the query examples .","title":"Dataview Query Language (DQL)"},{"location":"data-queries/#inline-dql","text":"The query language also provides inline queries, which allow you to embed single values directly inside a page - for example, todays date via = date(today) , or a field from another page via = [[Page]].value . You create inline queries using inline codeblocks: `= this.file.name` Inline DQL expressions are written using the query language expression language . You can configure inline queries to use a different prefix (like dv: or ~ ) in the Dataview settings.","title":"Inline DQL"},{"location":"data-queries/#dataview-js","text":"The dataview JavaScript API gives you the full power of JavaScript and provides a DSL for pulling Dataview data and executing queries, allowing you to create arbitrarily complex queries and views. Similar to the query language, you create Dataview JS blocks via a dataviewjs -annotated codeblock: ``` dataviewjs let pages = dv . pages ( \"#books and -#books/finished\" ). where ( b => b . rating >= 7 ); for ( let group of pages . groupBy ( b => b . genre )) { dv . header ( group . key ); dv . list ( group . rows . file . name ); } ``` Inside of a JS dataview block, you have access to the full dataview API via the dv variable. For an explanation of what you can do with it, see the API documentation , or the API examples .","title":"Dataview JS"},{"location":"data-queries/#inline-dataview-js","text":"Similar to the query language, you can write JS inline queries, which let you embed a computed JS value directly. You create JS inline queries via inline code blocks: `$= dv.current().file.mtime` In inline DataviewJS, you have access to the dv variable, as in dataviewjs codeblocks, and can make all of the same calls. The result should be something which evaluates to a JavaScript value, which Dataview will automatically render appropriately.","title":"Inline Dataview JS"},{"location":"api/code-examples/","text":"Codeblock Examples Grouped Books Group your books by genre, then create a table for each sorted by rating: for (let group of dv.pages(\"#book\").groupBy(p => p.genre)) { dv.header(3, group.key); dv.table([\"Name\", \"Time Read\", \"Rating\"], group.rows .sort(k => k.rating, 'desc') .map(k => [k.file.link, k[\"time-read\"], k.rating])) }","title":"Codeblock Examples"},{"location":"api/code-examples/#codeblock-examples","text":"","title":"Codeblock Examples"},{"location":"api/code-examples/#grouped-books","text":"Group your books by genre, then create a table for each sorted by rating: for (let group of dv.pages(\"#book\").groupBy(p => p.genre)) { dv.header(3, group.key); dv.table([\"Name\", \"Time Read\", \"Rating\"], group.rows .sort(k => k.rating, 'desc') .map(k => [k.file.link, k[\"time-read\"], k.rating])) }","title":"Grouped Books"},{"location":"api/code-reference/","text":"Codeblock Reference Dataview JavaScript Codeblocks are created using the dataviewjs language specification for a codeblock: ```dataviewjs dv.table([], ...) ``` The API is available through the implicitly provided dv (or dataview ) variable, through which you can query for information, render HTML, and configure the view. Asynchronous API calls are marked with \u231b . Query dv.current() Get page information (via dv.page() ) for the page the script is currently executing on. dv.pages(source) Takes a single string argument, source , which is the same form as a query language source . Returns a data array of page objects, which are plain objects with all of the page fields as values. dv . pages () => all pages in your vault dv . pages ( \"#books\" ) => all pages with tag 'books' dv . pages ( '\"folder\"' ) => all pages from folder \"folder\" dv . pages ( \"#yes or -#no\" ) => all pages with tag # yes , or which DON ' T have tag # no dv.pagePaths(source) As with dv.pages , but just returns a data array of paths of pages that match the given source. dv . pagePaths ( \"#books\" ) => the paths of pages with tag 'books' dv.page(path) Maps a simple path to the full page object, which includes all of the pages fields. Automatically does link resolution, and will figure out the extension automatically if not present. dv . page ( \"Index\" ) => The page object for /Index dv . page ( \"books/The Raisin.md\" ) => The page object for /books/The Raisin.md Render dv.el(text) Renders arbitrary text in the given html element. dv . el ( \"b\" , \"This is some bold text\" ); dv.header(level, text) Renders a header of level 1 - 6 with the given text. dv . header ( 1 , \"Big!\" ); dv . header ( 6 , \"Tiny\" ); dv.paragraph(text) Renders arbitrary text in a paragraph. dv . paragraph ( \"This is some text\" ); dv.span(text) Renders arbitrary text in a span (no padding above/below, unlike a paragraph). dv . span ( \"This is some text\" ); dv.view(path, input) Complex function which allows for custom views. Will attempt to load a JavaScript file at the given path, passing it dv and input and allowing it to execute. This allows for you to re-use custom view code across multiple pages. dv . view ( \"views/custom\" , { arg1 : ..., arg2 : ... }); If you want to also include custom CSS in your view, you can instead pass a path to a folder containing view.js and view.css ; the CSS will be added to the view automatically: views/custom -> view.js -> view.css View scripts have access to the dv object (the API object), and an input object which is exactly whatever the second argument of dv.view() was. Dataviews dv.list(elements) Render a dataview list of elements; accepts both vanilla arrays and data arrays. dv . list ([ 1 , 2 , 3 ]) => list of 1 , 2 , 3 dv . list ( dv . pages (). file . name ) => list of all file names dv . list ( dv . pages (). file . link ) => list of all file links dv . list ( dv . pages ( \"#book\" ). where ( p => p . rating > 7 )) => list of all books with rating greater than 7 dv.taskList(tasks, groupByFile) Render a dataview list of Task objects, as obtained by page.file.tasks . Only the first argument is required; if the second argument groupByFile is provided (and is true), then tasks will be grouped by the file they come from automatically. // List all tasks from pages marked '#project' dv . taskList ( dv . pages ( \"#project\" ). file . tasks ) // List all *uncompleted* tasks from pages marked #project dv . taskList ( dv . pages ( \"#project\" ). file . tasks . where ( t => ! t . completed )) // List all tasks tagged with '#tag' from pages marked #project dv . taskList ( dv . pages ( \"#project\" ). file . tasks . where ( t => t . text . includes ( \"#tag\" ))) dv.table(headers, elements) Render a dataview table with the given list of headers and 2D array of elements. // Render a simple table of book info sorted by rating. dv . table ([ \"File\" , \"Genre\" , \"Time Read\" , \"Rating\" ], dv . pages ( \"#book\" ) . sort ( b => b . rating ) . map ( b => [ b . file . link , b . genre , b [ \"time-read\" ], b . rating ])) Utility dv.array(value) Convert a given value or array into a Dataview data array . If the value is already a data array, returns it unchanged. dv . array ([ 1 , 2 , 3 ]) => dataview data array [ 1 , 2 , 3 ] dv.isArray(value) Returns true if the given value is an array or dataview array. dv . isArray ( dv . array ([ 1 , 2 , 3 ])) => true dv . isArray ([ 1 , 2 , 3 ]) => true dv . isArray ({ x : 1 }) => false dv.fileLink(path, [embed?], [display-name]) Converts a textual path into a Dataview Link object; you can optionally also specify if the link is embedded as well as it's display name. dv.fileLink() dv.date(text) Coerces text and links to luxon DateTime ; if provided with a DateTime , returns it unchanged. dv . date ( \"2021-08-08\" ) => DateTime for August 8 th , 2021 dv . date ( dv . fileLink ( \"2021-08-07\" )) => dateTime for August 8 th , 2021 dv.compare(a, b) Compare two arbitrary JavaScript values according to dataview's default comparison rules; useful if you are writing a custom comparator and want to fall back to the default behavior. Returns a negative value if a < b , 0 if a = b , and a positive value if a > b . dv.compare(1, 2) = -1 dv.compare(\"yes\", \"no\") = 1 dv.compare({ what: 0 }, { what: 0 }) = 0 dv.equal(a, b) Compare two arbitrary JavaScript values and return true if they are equal according to Dataview's default comparison rules. dv.equal(1, 2) = false dv.equal(1, 1) = true File I/O These utility methods are all contained in the dv.io sub-API, and are all asynchronous (marked by \u231b). \u231b dv.io.csv(path, [origin-file]) Load a CSV from the given path (a link or string). Relative paths will be resolved relative to the optional origin file (defaulting to the current file if not provided). Returns a dataview array, each element containing an object of the CSV values; if the file does not exist, returns undefined . await dv . io . csv ( \"hello.csv\" ) => [{ column1 : ..., column2 : ...}, ...] \u231b dv.io.load(path, [origin-file]) Load the contents of the given path (a link or string) asynchronously. Relative paths will bre resolved relative to the optional origi nfile (defaulting to the current file if not provided). Returns the string contents of the file, or undefined if the file does not exist. await dv . io . load ( \"File\" ) => \"# File\\nThis is an example file...\" dv.io.normalize(path, [origin-file]) Converts a relative link or path into an absolute path. If origin-file is provided, then the resolution is doing as if you were resolving the link from that file; if not, the path is resolved relative to the current file. dv . io . normalize ( \"Test\" ) => \"dataview/test/Test.md\" , if inside \"dataview/test\" dv . io . normalize ( \"Test\" , \"dataview/test2/Index.md\" ) => \"dataview/test2/Test.md\" , irrespective of the current file","title":"Codeblock Reference"},{"location":"api/code-reference/#codeblock-reference","text":"Dataview JavaScript Codeblocks are created using the dataviewjs language specification for a codeblock: ```dataviewjs dv.table([], ...) ``` The API is available through the implicitly provided dv (or dataview ) variable, through which you can query for information, render HTML, and configure the view. Asynchronous API calls are marked with \u231b .","title":"Codeblock Reference"},{"location":"api/code-reference/#query","text":"","title":"Query"},{"location":"api/code-reference/#dvcurrent","text":"Get page information (via dv.page() ) for the page the script is currently executing on.","title":"dv.current()"},{"location":"api/code-reference/#dvpagessource","text":"Takes a single string argument, source , which is the same form as a query language source . Returns a data array of page objects, which are plain objects with all of the page fields as values. dv . pages () => all pages in your vault dv . pages ( \"#books\" ) => all pages with tag 'books' dv . pages ( '\"folder\"' ) => all pages from folder \"folder\" dv . pages ( \"#yes or -#no\" ) => all pages with tag # yes , or which DON ' T have tag # no","title":"dv.pages(source)"},{"location":"api/code-reference/#dvpagepathssource","text":"As with dv.pages , but just returns a data array of paths of pages that match the given source. dv . pagePaths ( \"#books\" ) => the paths of pages with tag 'books'","title":"dv.pagePaths(source)"},{"location":"api/code-reference/#dvpagepath","text":"Maps a simple path to the full page object, which includes all of the pages fields. Automatically does link resolution, and will figure out the extension automatically if not present. dv . page ( \"Index\" ) => The page object for /Index dv . page ( \"books/The Raisin.md\" ) => The page object for /books/The Raisin.md","title":"dv.page(path)"},{"location":"api/code-reference/#render","text":"","title":"Render"},{"location":"api/code-reference/#dveltext","text":"Renders arbitrary text in the given html element. dv . el ( \"b\" , \"This is some bold text\" );","title":"dv.el(text)"},{"location":"api/code-reference/#dvheaderlevel-text","text":"Renders a header of level 1 - 6 with the given text. dv . header ( 1 , \"Big!\" ); dv . header ( 6 , \"Tiny\" );","title":"dv.header(level, text)"},{"location":"api/code-reference/#dvparagraphtext","text":"Renders arbitrary text in a paragraph. dv . paragraph ( \"This is some text\" );","title":"dv.paragraph(text)"},{"location":"api/code-reference/#dvspantext","text":"Renders arbitrary text in a span (no padding above/below, unlike a paragraph). dv . span ( \"This is some text\" );","title":"dv.span(text)"},{"location":"api/code-reference/#dvviewpath-input","text":"Complex function which allows for custom views. Will attempt to load a JavaScript file at the given path, passing it dv and input and allowing it to execute. This allows for you to re-use custom view code across multiple pages. dv . view ( \"views/custom\" , { arg1 : ..., arg2 : ... }); If you want to also include custom CSS in your view, you can instead pass a path to a folder containing view.js and view.css ; the CSS will be added to the view automatically: views/custom -> view.js -> view.css View scripts have access to the dv object (the API object), and an input object which is exactly whatever the second argument of dv.view() was.","title":"dv.view(path, input)"},{"location":"api/code-reference/#dataviews","text":"","title":"Dataviews"},{"location":"api/code-reference/#dvlistelements","text":"Render a dataview list of elements; accepts both vanilla arrays and data arrays. dv . list ([ 1 , 2 , 3 ]) => list of 1 , 2 , 3 dv . list ( dv . pages (). file . name ) => list of all file names dv . list ( dv . pages (). file . link ) => list of all file links dv . list ( dv . pages ( \"#book\" ). where ( p => p . rating > 7 )) => list of all books with rating greater than 7","title":"dv.list(elements)"},{"location":"api/code-reference/#dvtasklisttasks-groupbyfile","text":"Render a dataview list of Task objects, as obtained by page.file.tasks . Only the first argument is required; if the second argument groupByFile is provided (and is true), then tasks will be grouped by the file they come from automatically. // List all tasks from pages marked '#project' dv . taskList ( dv . pages ( \"#project\" ). file . tasks ) // List all *uncompleted* tasks from pages marked #project dv . taskList ( dv . pages ( \"#project\" ). file . tasks . where ( t => ! t . completed )) // List all tasks tagged with '#tag' from pages marked #project dv . taskList ( dv . pages ( \"#project\" ). file . tasks . where ( t => t . text . includes ( \"#tag\" )))","title":"dv.taskList(tasks, groupByFile)"},{"location":"api/code-reference/#dvtableheaders-elements","text":"Render a dataview table with the given list of headers and 2D array of elements. // Render a simple table of book info sorted by rating. dv . table ([ \"File\" , \"Genre\" , \"Time Read\" , \"Rating\" ], dv . pages ( \"#book\" ) . sort ( b => b . rating ) . map ( b => [ b . file . link , b . genre , b [ \"time-read\" ], b . rating ]))","title":"dv.table(headers, elements)"},{"location":"api/code-reference/#utility","text":"","title":"Utility"},{"location":"api/code-reference/#dvarrayvalue","text":"Convert a given value or array into a Dataview data array . If the value is already a data array, returns it unchanged. dv . array ([ 1 , 2 , 3 ]) => dataview data array [ 1 , 2 , 3 ]","title":"dv.array(value)"},{"location":"api/code-reference/#dvisarrayvalue","text":"Returns true if the given value is an array or dataview array. dv . isArray ( dv . array ([ 1 , 2 , 3 ])) => true dv . isArray ([ 1 , 2 , 3 ]) => true dv . isArray ({ x : 1 }) => false","title":"dv.isArray(value)"},{"location":"api/code-reference/#dvfilelinkpath-embed-display-name","text":"Converts a textual path into a Dataview Link object; you can optionally also specify if the link is embedded as well as it's display name. dv.fileLink()","title":"dv.fileLink(path, [embed?], [display-name])"},{"location":"api/code-reference/#dvdatetext","text":"Coerces text and links to luxon DateTime ; if provided with a DateTime , returns it unchanged. dv . date ( \"2021-08-08\" ) => DateTime for August 8 th , 2021 dv . date ( dv . fileLink ( \"2021-08-07\" )) => dateTime for August 8 th , 2021","title":"dv.date(text)"},{"location":"api/code-reference/#dvcomparea-b","text":"Compare two arbitrary JavaScript values according to dataview's default comparison rules; useful if you are writing a custom comparator and want to fall back to the default behavior. Returns a negative value if a < b , 0 if a = b , and a positive value if a > b . dv.compare(1, 2) = -1 dv.compare(\"yes\", \"no\") = 1 dv.compare({ what: 0 }, { what: 0 }) = 0","title":"dv.compare(a, b)"},{"location":"api/code-reference/#dvequala-b","text":"Compare two arbitrary JavaScript values and return true if they are equal according to Dataview's default comparison rules. dv.equal(1, 2) = false dv.equal(1, 1) = true","title":"dv.equal(a, b)"},{"location":"api/code-reference/#file-io","text":"These utility methods are all contained in the dv.io sub-API, and are all asynchronous (marked by \u231b).","title":"File I/O"},{"location":"api/code-reference/#dviocsvpath-origin-file","text":"Load a CSV from the given path (a link or string). Relative paths will be resolved relative to the optional origin file (defaulting to the current file if not provided). Returns a dataview array, each element containing an object of the CSV values; if the file does not exist, returns undefined . await dv . io . csv ( \"hello.csv\" ) => [{ column1 : ..., column2 : ...}, ...]","title":"\u231b dv.io.csv(path, [origin-file])"},{"location":"api/code-reference/#dvioloadpath-origin-file","text":"Load the contents of the given path (a link or string) asynchronously. Relative paths will bre resolved relative to the optional origi nfile (defaulting to the current file if not provided). Returns the string contents of the file, or undefined if the file does not exist. await dv . io . load ( \"File\" ) => \"# File\\nThis is an example file...\"","title":"\u231b dv.io.load(path, [origin-file])"},{"location":"api/code-reference/#dvionormalizepath-origin-file","text":"Converts a relative link or path into an absolute path. If origin-file is provided, then the resolution is doing as if you were resolving the link from that file; if not, the path is resolved relative to the current file. dv . io . normalize ( \"Test\" ) => \"dataview/test/Test.md\" , if inside \"dataview/test\" dv . io . normalize ( \"Test\" , \"dataview/test2/Index.md\" ) => \"dataview/test2/Test.md\" , irrespective of the current file","title":"dv.io.normalize(path, [origin-file])"},{"location":"api/data-array/","text":"Data Arrays The general abstraction for lists of results in Dataview is the DataArray , which is a proxied array with additional functionality. Data arrays support indexing and iteration (via for and for ... of loops) as per normal arrays, but also include many data manipulation operators like sort , groupBy , distinct , where , and so on to make mainpulating tabular data easy. Creation Data arrays are returned by most Dataview APIs that can return multiple results, such as dv.pages() . You can also explicitly convert a normal JavaScript array into a Dataview array using dv.array(<array>) . If you want to convert a Data array back to a normal array, use DataArray#array() . Indexing and Swizzling Data arrays support regular indexing just like normal arrays (like array[0] ), but importantly, they also support query-language-style \"swizzling\": if you index into a data array with a field name (like array.field ), it automatically maps every element in the array to field , flattening field if it itself is also an array. For example, dv.pages().file.name will return a data array of all file names in your vault; dv.pages(\"#books\").genres will return a flattened list of all genres in your books. Raw Interface The full interface for the data array implementation is provided below for reference: /** A function which maps an array element to some value. */ export type ArrayFunc < T , O > = ( elem : T , index : number , arr : T []) => O ; /** A function which compares two types. */ export type ArrayComparator < T > = ( a : T , b : T ) => number ; /** * Proxied interface which allows manipulating array-based data. All functions on a data array produce a NEW array * (i.e., the arrays are immutable). */ export interface DataArray < T > { /** The total number of elements in the array. */ length : number ; /** Filter the data array down to just elements which match the given predicate. */ where ( predicate : ArrayFunc < T , boolean > ) : DataArray < T > ; /** Alias for 'where' for people who want array semantics. */ filter ( predicate : ArrayFunc < T , boolean > ) : DataArray < T > ; /** Map elements in the data array by applying a function to each. */ map < U > ( f : ArrayFunc < T , U > ) : DataArray < U > ; /** Map elements in the data array by applying a function to each, then flatten the results to produce a new array. */ flatMap < U > ( f : ArrayFunc < T , U [] > ) : DataArray < U > ; /** Mutably change each value in the array, returning the same array which you can further chain off of. */ mutate ( f : ArrayFunc < T , any > ) : DataArray < any > ; /** Limit the total number of entries in the array to the given value. */ limit ( count : number ) : DataArray < T > ; /** * Take a slice of the array. If `start` is undefined, it is assumed to be 0; if `end` is undefined, it is assumbed * to be the end of the array. */ slice ( start? : number , end? : number ) : DataArray < T > ; /** Concatenate the values in this data array with those of another iterable / data array / array. */ concat ( other : Iterable < T > ) : DataArray < T > ; /** Return the first index of the given (optionally starting the search) */ indexOf ( element : T , fromIndex? : number ) : number ; /** Return the first element that satisfies the given predicate. */ find ( pred : ArrayFunc < T , boolean > ) : T | undefined ; /** Find the index of the first element that satisfies the given predicate. Returns -1 if nothing was found. */ findIndex ( pred : ArrayFunc < T , boolean > , fromIndex? : number ) : number ; /** Returns true if the array contains the given element, and false otherwise. */ includes ( element : T ) : boolean ; /** * Return a string obtained by converting each element in the array to a string, and joining it with the * given separator (which defaults to ', '). */ join ( sep? : string ) : string ; /** * Return a sorted array sorted by the given key; an optional comparator can be provided, which will * be used to compare the keys in leiu of the default dataview comparator. */ sort < U > ( key : ArrayFunc < T , U > , direction ?: \"asc\" | \"desc\" , comparator? : ArrayComparator < U > ) : DataArray < T > ; /** * Return an array where elements are grouped by the given key; the resulting array will have objects of the form * { key: <key value>, rows: DataArray }. */ groupBy < U > ( key : ArrayFunc < T , U > , comparator? : ArrayComparator < U > ) : DataArray < { key : U ; rows : DataArray < T > } > ; /** * Return distinct entries. If a key is provided, then rows with distinct keys are returned. */ distinct < U > ( key? : ArrayFunc < T , U > , comparator? : ArrayComparator < U > ) : DataArray < T > ; /** Return true if the predicate is true for all values. */ every ( f : ArrayFunc < T , boolean > ) : boolean ; /** Return true if the predicate is true for at least one value. */ some ( f : ArrayFunc < T , boolean > ) : boolean ; /** Return true if the predicate is FALSE for all values. */ none ( f : ArrayFunc < T , boolean > ) : boolean ; /** Return the first element in the data array. Returns undefined if the array is empty. */ first () : T ; /** Return the last element in the data array. Returns undefined if the array is empty. */ last () : T ; /** Map every element in this data array to the given key, and then flatten it.*/ to ( key : string ) : DataArray < any > ; /** * Recursively expand the given key, flattening a tree structure based on the key into a flat array. Useful for handling * heirarchical data like tasks with 'subtasks'. */ expand ( key : string ) : DataArray < any > ; /** Run a lambda on each element in the array. */ forEach ( f : ArrayFunc < T , void > ) : void ; /** Convert this to a plain javascript array. */ array () : T []; /** Allow iterating directly over the array. */ [ Symbol . iterator ]() : Iterator < T > ; /** Map indexes to values. */ [ index : number ] : any ; /** Automatic flattening of fields. Equivalent to implicitly calling `array.to(\"field\")` */ [ field : string ] : any ; }","title":"Data Arrays"},{"location":"api/data-array/#data-arrays","text":"The general abstraction for lists of results in Dataview is the DataArray , which is a proxied array with additional functionality. Data arrays support indexing and iteration (via for and for ... of loops) as per normal arrays, but also include many data manipulation operators like sort , groupBy , distinct , where , and so on to make mainpulating tabular data easy.","title":"Data Arrays"},{"location":"api/data-array/#creation","text":"Data arrays are returned by most Dataview APIs that can return multiple results, such as dv.pages() . You can also explicitly convert a normal JavaScript array into a Dataview array using dv.array(<array>) . If you want to convert a Data array back to a normal array, use DataArray#array() .","title":"Creation"},{"location":"api/data-array/#indexing-and-swizzling","text":"Data arrays support regular indexing just like normal arrays (like array[0] ), but importantly, they also support query-language-style \"swizzling\": if you index into a data array with a field name (like array.field ), it automatically maps every element in the array to field , flattening field if it itself is also an array. For example, dv.pages().file.name will return a data array of all file names in your vault; dv.pages(\"#books\").genres will return a flattened list of all genres in your books.","title":"Indexing and Swizzling"},{"location":"api/data-array/#raw-interface","text":"The full interface for the data array implementation is provided below for reference: /** A function which maps an array element to some value. */ export type ArrayFunc < T , O > = ( elem : T , index : number , arr : T []) => O ; /** A function which compares two types. */ export type ArrayComparator < T > = ( a : T , b : T ) => number ; /** * Proxied interface which allows manipulating array-based data. All functions on a data array produce a NEW array * (i.e., the arrays are immutable). */ export interface DataArray < T > { /** The total number of elements in the array. */ length : number ; /** Filter the data array down to just elements which match the given predicate. */ where ( predicate : ArrayFunc < T , boolean > ) : DataArray < T > ; /** Alias for 'where' for people who want array semantics. */ filter ( predicate : ArrayFunc < T , boolean > ) : DataArray < T > ; /** Map elements in the data array by applying a function to each. */ map < U > ( f : ArrayFunc < T , U > ) : DataArray < U > ; /** Map elements in the data array by applying a function to each, then flatten the results to produce a new array. */ flatMap < U > ( f : ArrayFunc < T , U [] > ) : DataArray < U > ; /** Mutably change each value in the array, returning the same array which you can further chain off of. */ mutate ( f : ArrayFunc < T , any > ) : DataArray < any > ; /** Limit the total number of entries in the array to the given value. */ limit ( count : number ) : DataArray < T > ; /** * Take a slice of the array. If `start` is undefined, it is assumed to be 0; if `end` is undefined, it is assumbed * to be the end of the array. */ slice ( start? : number , end? : number ) : DataArray < T > ; /** Concatenate the values in this data array with those of another iterable / data array / array. */ concat ( other : Iterable < T > ) : DataArray < T > ; /** Return the first index of the given (optionally starting the search) */ indexOf ( element : T , fromIndex? : number ) : number ; /** Return the first element that satisfies the given predicate. */ find ( pred : ArrayFunc < T , boolean > ) : T | undefined ; /** Find the index of the first element that satisfies the given predicate. Returns -1 if nothing was found. */ findIndex ( pred : ArrayFunc < T , boolean > , fromIndex? : number ) : number ; /** Returns true if the array contains the given element, and false otherwise. */ includes ( element : T ) : boolean ; /** * Return a string obtained by converting each element in the array to a string, and joining it with the * given separator (which defaults to ', '). */ join ( sep? : string ) : string ; /** * Return a sorted array sorted by the given key; an optional comparator can be provided, which will * be used to compare the keys in leiu of the default dataview comparator. */ sort < U > ( key : ArrayFunc < T , U > , direction ?: \"asc\" | \"desc\" , comparator? : ArrayComparator < U > ) : DataArray < T > ; /** * Return an array where elements are grouped by the given key; the resulting array will have objects of the form * { key: <key value>, rows: DataArray }. */ groupBy < U > ( key : ArrayFunc < T , U > , comparator? : ArrayComparator < U > ) : DataArray < { key : U ; rows : DataArray < T > } > ; /** * Return distinct entries. If a key is provided, then rows with distinct keys are returned. */ distinct < U > ( key? : ArrayFunc < T , U > , comparator? : ArrayComparator < U > ) : DataArray < T > ; /** Return true if the predicate is true for all values. */ every ( f : ArrayFunc < T , boolean > ) : boolean ; /** Return true if the predicate is true for at least one value. */ some ( f : ArrayFunc < T , boolean > ) : boolean ; /** Return true if the predicate is FALSE for all values. */ none ( f : ArrayFunc < T , boolean > ) : boolean ; /** Return the first element in the data array. Returns undefined if the array is empty. */ first () : T ; /** Return the last element in the data array. Returns undefined if the array is empty. */ last () : T ; /** Map every element in this data array to the given key, and then flatten it.*/ to ( key : string ) : DataArray < any > ; /** * Recursively expand the given key, flattening a tree structure based on the key into a flat array. Useful for handling * heirarchical data like tasks with 'subtasks'. */ expand ( key : string ) : DataArray < any > ; /** Run a lambda on each element in the array. */ forEach ( f : ArrayFunc < T , void > ) : void ; /** Convert this to a plain javascript array. */ array () : T []; /** Allow iterating directly over the array. */ [ Symbol . iterator ]() : Iterator < T > ; /** Map indexes to values. */ [ index : number ] : any ; /** Automatic flattening of fields. Equivalent to implicitly calling `array.to(\"field\")` */ [ field : string ] : any ; }","title":"Raw Interface"},{"location":"api/intro/","text":"Overview The Dataview JavaScript API allows for executing arbitrary JavaScript with access to the dataview indices and query engine, which is good for complex views or interop with other plugins. The API comes in two flavors: plugin facing, and user facing (or 'inline API usage'). Inline Access You can create a \"DataviewJS\" block via: ```dataviewjs dv.pages(\"#thing\")... ``` Code executed in such codeblocks have access to the dv variable, which provides the entirety of the codeblock-relevant dataview API (like dv.table() , dv.pages() , and so on). For more information, check out the codeblock API reference . Plugin Access You can access the Dataview Plugin API (from other plugins or the console) through app.plugins.plugins.dataview.api ; this API is similar to the codeblock reference, with slightly different arguments due to the lack of an implicit file to execute the queries in. For more information, check out the Plugin API reference .","title":"Overview"},{"location":"api/intro/#overview","text":"The Dataview JavaScript API allows for executing arbitrary JavaScript with access to the dataview indices and query engine, which is good for complex views or interop with other plugins. The API comes in two flavors: plugin facing, and user facing (or 'inline API usage').","title":"Overview"},{"location":"api/intro/#inline-access","text":"You can create a \"DataviewJS\" block via: ```dataviewjs dv.pages(\"#thing\")... ``` Code executed in such codeblocks have access to the dv variable, which provides the entirety of the codeblock-relevant dataview API (like dv.table() , dv.pages() , and so on). For more information, check out the codeblock API reference .","title":"Inline Access"},{"location":"api/intro/#plugin-access","text":"You can access the Dataview Plugin API (from other plugins or the console) through app.plugins.plugins.dataview.api ; this API is similar to the codeblock reference, with slightly different arguments due to the lack of an implicit file to execute the queries in. For more information, check out the Plugin API reference .","title":"Plugin Access"},{"location":"plugin/develop-against-dataview/","text":"Developing Against Dataview Dataview includes a high-level plugin-facing API as well as TypeScript definitions and a utility library; to set it up for your plugin, follow these steps: Install the utility library and types via npm install -D obsidian-dataview in your plugin directory. Create a types file types.d.ts , with the contents below, which adds some dataview-related event typings and provides access to app.plugins : import \"obsidian\" ; import { DataviewApi } from \"obsidian-dataview\" ; declare module \"obsidian\" { interface App { plugins : { enabledPlugins : Set < string > ; plugins : { [ id : string ] : any ; dataview ?: { api? : DataviewApi ; }; }; }; } interface MetadataCache { on ( name : \"dataview:api-ready\" , callback : ( api : DataviewPlugin [ \"api\" ]) => any , ctx? : any ) : EventRef ; on ( name : \"dataview:metadata-change\" , callback : ( ... args : | [ op : \"rename\" , file : TAbstractFile , oldPath : string ] | [ op : \"delete\" , file : TFile ] | [ op : \"update\" , file : TFile ] ) => any , ctx? : any ) : EventRef ; } } Following these steps will allow you to access Dataview in a typed way, including doing things such as: Checking if Dataview is enabled : plugin.app.enabledPlugins.has(\"dataview\") . Accessing the Dataview API : plugin.app.plugins.dataview?.api . Bind to Dataview events : plugin.registerEvent(plugin.app.metadataCache.on(\"dataview:...\", (...) => ...)) . Using the Dataview API Programatically The Dataview API takes a short amount of time to initialize before being available (during which it may be undefined or in an unknown state). To ensure the API is available, you can wait on the metadata cache dataview:api-ready event, such as in the idiom below: async onload () { const doSomethingWith = ( api : DataviewPlugin [ \"api\" ]) => { // do something }; if ( this . app . enabledPlugins . has ( \"dataview\" )) { const api = this . app . plugins . dataview ? . api ; if ( api ) doSomethingWith ( api ); else this . registerEvent ( this . app . metadataCache . on ( \"dataview:api-ready\" , ( api ) => doSomethingWith ( api ) ) ); } } Value Utilities You can access various type utilities which let you check the types of objects and compare them via Values : import { Values } from \"obsidian-dataview\" const field = plugin . app . plugins . dataview ? . api . page ( 'sample.md' ). field ; if ( ! field ) return ; if ( Values . isHtml ( field )) // do something else if ( Values . isLink ( field )) // do something // ...","title":"Developing Against Dataview"},{"location":"plugin/develop-against-dataview/#developing-against-dataview","text":"Dataview includes a high-level plugin-facing API as well as TypeScript definitions and a utility library; to set it up for your plugin, follow these steps: Install the utility library and types via npm install -D obsidian-dataview in your plugin directory. Create a types file types.d.ts , with the contents below, which adds some dataview-related event typings and provides access to app.plugins : import \"obsidian\" ; import { DataviewApi } from \"obsidian-dataview\" ; declare module \"obsidian\" { interface App { plugins : { enabledPlugins : Set < string > ; plugins : { [ id : string ] : any ; dataview ?: { api? : DataviewApi ; }; }; }; } interface MetadataCache { on ( name : \"dataview:api-ready\" , callback : ( api : DataviewPlugin [ \"api\" ]) => any , ctx? : any ) : EventRef ; on ( name : \"dataview:metadata-change\" , callback : ( ... args : | [ op : \"rename\" , file : TAbstractFile , oldPath : string ] | [ op : \"delete\" , file : TFile ] | [ op : \"update\" , file : TFile ] ) => any , ctx? : any ) : EventRef ; } } Following these steps will allow you to access Dataview in a typed way, including doing things such as: Checking if Dataview is enabled : plugin.app.enabledPlugins.has(\"dataview\") . Accessing the Dataview API : plugin.app.plugins.dataview?.api . Bind to Dataview events : plugin.registerEvent(plugin.app.metadataCache.on(\"dataview:...\", (...) => ...)) .","title":"Developing Against Dataview"},{"location":"plugin/develop-against-dataview/#using-the-dataview-api-programatically","text":"The Dataview API takes a short amount of time to initialize before being available (during which it may be undefined or in an unknown state). To ensure the API is available, you can wait on the metadata cache dataview:api-ready event, such as in the idiom below: async onload () { const doSomethingWith = ( api : DataviewPlugin [ \"api\" ]) => { // do something }; if ( this . app . enabledPlugins . has ( \"dataview\" )) { const api = this . app . plugins . dataview ? . api ; if ( api ) doSomethingWith ( api ); else this . registerEvent ( this . app . metadataCache . on ( \"dataview:api-ready\" , ( api ) => doSomethingWith ( api ) ) ); } }","title":"Using the Dataview API Programatically"},{"location":"plugin/develop-against-dataview/#value-utilities","text":"You can access various type utilities which let you check the types of objects and compare them via Values : import { Values } from \"obsidian-dataview\" const field = plugin . app . plugins . dataview ? . api . page ( 'sample.md' ). field ; if ( ! field ) return ; if ( Values . isHtml ( field )) // do something else if ( Values . isLink ( field )) // do something // ...","title":"Value Utilities"},{"location":"query/examples/","text":"Examples A small collection of simple usages of the dataview query language. Show all games in the games folder, sorted by rating, with some metadata: Query TABLE time - played AS \"Time Played\" , length AS \"Length\" , rating AS \"Rating\" FROM \"games\" SORT rating DESC Output File Time Played Length Rating Outer Wilds November 19th - 21st, 2020 15h 9.5 Minecraft All the time. 2000h 9.5 Pillars of Eternity 2 August - October 2019 100h 9 List games which are MOBAs or CRPGs. Query LIST FROM # games / mobas OR # games / crpg Output League of Legends Pillars of Eternity 2 List all tasks in un-completed projects: Query TASK FROM \"dataview\" Output dataview/Project A I am a task. I am another task. dataview/Project A I could be a task, though who knows. Determine if this is a task. I'm a finished task. List all of the files in the books folder, sorted by the last time you modifed the file: Query TABLE file . mtime AS \"Last Modified\" FROM \"books\" SORT file . mtime DESC Output File Last Modified Atomic Habits 11:06 PM - August 07, 2021 Can't Hurt Me 10:58 PM - August 07, 2021 Deep Work 10:52 PM - August 07, 2021 List all files which have a date in their title (of the form yyyy-mm-dd ), and list them by date order. Query LIST file . day WHERE file . day SORT file . day DESC Output 2021-08-07 : August 07, 2021 2020-08-10 : August 10, 2020","title":"Examples"},{"location":"query/examples/#examples","text":"A small collection of simple usages of the dataview query language. Show all games in the games folder, sorted by rating, with some metadata: Query TABLE time - played AS \"Time Played\" , length AS \"Length\" , rating AS \"Rating\" FROM \"games\" SORT rating DESC Output File Time Played Length Rating Outer Wilds November 19th - 21st, 2020 15h 9.5 Minecraft All the time. 2000h 9.5 Pillars of Eternity 2 August - October 2019 100h 9 List games which are MOBAs or CRPGs. Query LIST FROM # games / mobas OR # games / crpg Output League of Legends Pillars of Eternity 2 List all tasks in un-completed projects: Query TASK FROM \"dataview\" Output dataview/Project A I am a task. I am another task. dataview/Project A I could be a task, though who knows. Determine if this is a task. I'm a finished task. List all of the files in the books folder, sorted by the last time you modifed the file: Query TABLE file . mtime AS \"Last Modified\" FROM \"books\" SORT file . mtime DESC Output File Last Modified Atomic Habits 11:06 PM - August 07, 2021 Can't Hurt Me 10:58 PM - August 07, 2021 Deep Work 10:52 PM - August 07, 2021 List all files which have a date in their title (of the form yyyy-mm-dd ), and list them by date order. Query LIST file . day WHERE file . day SORT file . day DESC Output 2021-08-07 : August 07, 2021 2020-08-10 : August 10, 2020","title":"Examples"},{"location":"query/expressions/","text":"Expressions Dataview query language expressions are anything that yields a value - all fields are expressions, as are literal values (like 6 ), as are computed values (like field - 9 ). For a very high level summary: # Literals 1 (number) true/false (boolean) \"text\" (text) date(2021-04-18) (date) dur(1 day) (duration) [[Link]] (link) [1, 2, 3] (list) { a: 1, b: 2 } (object) # Lambdas (x1, x2) => ... (lambda) # References field (directly refer to a field) simple-field (refer to fields with spaces/punctuation in them like \"Simple Field!\") a.b (if a is an object, retrieve field named 'b') a[expr] (if a is an object or array, retrieve field with name specified by expression 'expr') f(a, b, ...) (call a function called `f` on arguments a, b, ...) # Arithmetic a + b (addition) a - b (subtraction) a * b (multiplication) a / b (division) # Comparison a > b (check if a is greater than b) a < b (check if a is less than b) a = b (check if a equals b) a != b (check if a does not equal b) a <= b (check if a is less than or equal to b) a >= b (check if a is greater than or equal to b) # Special Operations [[Link]].value (fetch `value` from page `Link`) More detailed explanations of each follow. Expression Types Fields as Expressions The simplest expression is one that just directly refers to a field. If you have a field called \"field\", then you can refer to it directly by name - field . If the field name has spaces, punctuation, or other non-letter/number characters, then you can refer to it using Dataview's simplified name, which is all lower case with spaces replaced with \"-\". For example, this is a field becomes this-is-a-field ; Hello! becomes hello , and so on. Literals Constant values - things like 1 or \"hello\" or date(som) (\"start of month\"). There are literals for each data type that dataview supports; you can see the reference above for examples of what each literal type looks like. Arithmetic You can use standard arithmetic operators to combine fields: addition ( + ), subtraction ( - ), multiplication ( * ), and division ( / ). For example field1 + field2 is an expression which computes the sum of the two fields. Comparisons You can compare most values using the various comparison operators: < , > , <= , >= , = , != . This yields a boolean true or false value which can be used in WHERE blocks in queries. Array/Object Indexing You can retrieve data from arrays via the index operator array[<index>] , where <index> is any computed expression. Arrays are 0-indexed, so the first element is index 0, the second element is index 1, and so on. For example list(1, 2, 3)[0] = 1 . You can retrieve data from objects (which map text to data values) also using the index operator, where indexes are now strings/text instead of numbers. You can also use the shorthand object.<name> , where <name> is the name of the value to retrieve. For example object(\"yes\", 1).yes = 1 . Function Calls Dataview supports various functions for manipulating data, which are described in full in the functions documentation . They have the general syntax function(arg1, arg2, ...) - i.e., lower(\"yes\") or regexmatch(\"text\", \".+\") . Lambdas Lambdas are advanced literals which let you define a function that takes some number of inputs, and produces an output. They have the general form: (arg1, arg2, arg3, ...) => <expression using args> Lambdas are used in several advanced operators like reduce and map to allow for complex transformations of data. A few examples: (x, y) => x + y (sum x and y) (x) => 2 * x (double x) (value) => length(value) = 4 (return true if value is length 4) Type-specific Interactions & Values Most dataview types have special interactions with operators, or have additional fields that can be retrieved using the index operator. Dates You can retrieve various components of a date via indexing: date.year , date.month , date.day , date.hour , date.minute , date.second , date.week . You can also add durations to dates to get new dates. Durations Durations can be added to each other or to dates. You can retrieve various components of a duration via indexing: duration.years , duration.months , duration.days , duration.hours , duration.minutes , duration.seconds . Links You can \"index through\" a link to get values on the corresponding page. For example [[Link]].value would get the value value from page Link . Link Indexing in Expressions If your link is a field that you defined in an inline field or in front-matter, like Key:: [[Link]] , then you should index into it by just writing Key.value ; Using [[Key]].value would look up the page literally called Key , which is probably not what you want!","title":"Expressions"},{"location":"query/expressions/#expressions","text":"Dataview query language expressions are anything that yields a value - all fields are expressions, as are literal values (like 6 ), as are computed values (like field - 9 ). For a very high level summary: # Literals 1 (number) true/false (boolean) \"text\" (text) date(2021-04-18) (date) dur(1 day) (duration) [[Link]] (link) [1, 2, 3] (list) { a: 1, b: 2 } (object) # Lambdas (x1, x2) => ... (lambda) # References field (directly refer to a field) simple-field (refer to fields with spaces/punctuation in them like \"Simple Field!\") a.b (if a is an object, retrieve field named 'b') a[expr] (if a is an object or array, retrieve field with name specified by expression 'expr') f(a, b, ...) (call a function called `f` on arguments a, b, ...) # Arithmetic a + b (addition) a - b (subtraction) a * b (multiplication) a / b (division) # Comparison a > b (check if a is greater than b) a < b (check if a is less than b) a = b (check if a equals b) a != b (check if a does not equal b) a <= b (check if a is less than or equal to b) a >= b (check if a is greater than or equal to b) # Special Operations [[Link]].value (fetch `value` from page `Link`) More detailed explanations of each follow.","title":"Expressions"},{"location":"query/expressions/#expression-types","text":"","title":"Expression Types"},{"location":"query/expressions/#fields-as-expressions","text":"The simplest expression is one that just directly refers to a field. If you have a field called \"field\", then you can refer to it directly by name - field . If the field name has spaces, punctuation, or other non-letter/number characters, then you can refer to it using Dataview's simplified name, which is all lower case with spaces replaced with \"-\". For example, this is a field becomes this-is-a-field ; Hello! becomes hello , and so on.","title":"Fields as Expressions"},{"location":"query/expressions/#literals","text":"Constant values - things like 1 or \"hello\" or date(som) (\"start of month\"). There are literals for each data type that dataview supports; you can see the reference above for examples of what each literal type looks like.","title":"Literals"},{"location":"query/expressions/#arithmetic","text":"You can use standard arithmetic operators to combine fields: addition ( + ), subtraction ( - ), multiplication ( * ), and division ( / ). For example field1 + field2 is an expression which computes the sum of the two fields.","title":"Arithmetic"},{"location":"query/expressions/#comparisons","text":"You can compare most values using the various comparison operators: < , > , <= , >= , = , != . This yields a boolean true or false value which can be used in WHERE blocks in queries.","title":"Comparisons"},{"location":"query/expressions/#arrayobject-indexing","text":"You can retrieve data from arrays via the index operator array[<index>] , where <index> is any computed expression. Arrays are 0-indexed, so the first element is index 0, the second element is index 1, and so on. For example list(1, 2, 3)[0] = 1 . You can retrieve data from objects (which map text to data values) also using the index operator, where indexes are now strings/text instead of numbers. You can also use the shorthand object.<name> , where <name> is the name of the value to retrieve. For example object(\"yes\", 1).yes = 1 .","title":"Array/Object Indexing"},{"location":"query/expressions/#function-calls","text":"Dataview supports various functions for manipulating data, which are described in full in the functions documentation . They have the general syntax function(arg1, arg2, ...) - i.e., lower(\"yes\") or regexmatch(\"text\", \".+\") .","title":"Function Calls"},{"location":"query/expressions/#lambdas","text":"Lambdas are advanced literals which let you define a function that takes some number of inputs, and produces an output. They have the general form: (arg1, arg2, arg3, ...) => <expression using args> Lambdas are used in several advanced operators like reduce and map to allow for complex transformations of data. A few examples: (x, y) => x + y (sum x and y) (x) => 2 * x (double x) (value) => length(value) = 4 (return true if value is length 4)","title":"Lambdas"},{"location":"query/expressions/#type-specific-interactions-values","text":"Most dataview types have special interactions with operators, or have additional fields that can be retrieved using the index operator.","title":"Type-specific Interactions &amp; Values"},{"location":"query/expressions/#dates","text":"You can retrieve various components of a date via indexing: date.year , date.month , date.day , date.hour , date.minute , date.second , date.week . You can also add durations to dates to get new dates.","title":"Dates"},{"location":"query/expressions/#durations","text":"Durations can be added to each other or to dates. You can retrieve various components of a duration via indexing: duration.years , duration.months , duration.days , duration.hours , duration.minutes , duration.seconds .","title":"Durations"},{"location":"query/expressions/#links","text":"You can \"index through\" a link to get values on the corresponding page. For example [[Link]].value would get the value value from page Link . Link Indexing in Expressions If your link is a field that you defined in an inline field or in front-matter, like Key:: [[Link]] , then you should index into it by just writing Key.value ; Using [[Key]].value would look up the page literally called Key , which is probably not what you want!","title":"Links"},{"location":"query/functions/","text":"Functions Dataview functions provide more advanced ways to manipulate data. Function Vectorization Most functions can be applied either to single values (like number , string , date , etc.) OR to lists of those values. If a function is applied to a list, it also returns a list after the function is applied to each element in the list. For example: lower(\"YES\") = \"yes\" lower(list(\"YES\", \"NO\")) = list(\"yes\", \"no\") replace(\"yes\", \"e\", \"a\") = \"yas\" replace(list(\"yes\", \"ree\"), \"e\", \"a\") = list(\"yas\", \"raa\") Constructors Constructors which create values. object(key1, value1, ...) Creates a new object with the given keys and values. Keys and values should alternate in the call, and keys should always be strings/text. object() => empty object object(\"a\", 6) => object which maps \"a\" to 6 object(\"a\", 4, \"c\", \"yes\") => object which maps a to 4, and c to \"yes\" list(value1, value2, ...) Creates a new list with the given values in it. list() => empty list list(1, 2, 3) => list with 1, 2, and 3 list(\"a\", \"b\", \"c\") => list with \"a\", \"b\", and \"c\" date(any) Parses a date from the provided string, date, or link object, if possible, returning null otherwise. date(\"2020-04-18\") = <date object representing April 18th, 2020> date([[2021-04-16]]) = <date object for the given page, refering to file.day> number(string) Pulls the first number out of the given string, returning it if possible. Returns null if there are no numbers in the string. number(\"18 years\") = 18 number(34) = 34 number(\"hmm\") = null string(any) Converts any value into a \"reasonable\" string representation. This sometimes produces less pretty results than just directly using the value in a query - it is mostly useful for coercing dates, durations, numbers, and so on into strings for manipulation. string(18) = \"18\" string(dur(8 hours)) = \"8 hours\" string(date(2021-08-15)) = \"August 15th, 2021\" link(path, [display]) Construct a link object from the given file path or name. If provided with two arguments, the second argument is the display name for the link. link(\"Hello\") => link to page named 'Hello' link(\"Hello\", \"Goodbye\") => link to page named 'Hello', displays as 'Goodbye' elink(url, [display]) Construct a link to an external url (like www.google.com ). If provided with two arguments, the second argument is the display name for the link. elink(\"www.google.com\") => link element to google.com elink(\"www.google.com\", \"Google\") => link element to google.com, displays as \"Google\" Numeric Operations round(number, [digits]) Round a number to a given number of digits. If the second argument is not specified, rounds to the nearest whole number; otherwise, rounds to the given number of digits. round(16.555555) = 7 round(16.555555, 2) = 16.56 -- Objects, Arrays, and String Operations Operations that manipulate values inside of container objects. contains(object|list|string, value) Checks if the given container type has the given value in it. This function behave slightly differently based on whether the first argument is an object, a list, or a string. For objects, checks if the object has a key with the given name. For example, contains(file, \"ctime\") = true contains(file, \"day\") = true (if file has a date in its title, false otherwise) For lists, checks if any of the array elements equals the given value. For example, contains(list(1, 2, 3), 3) = true contains(list(), 1) = false For strings, checks if the given value is a substring (i.e., inside) the string. contains(\"hello\", \"lo\") = true contains(\"yes\", \"no\") = false extract(object, key1, key2, ...) Pulls multiple fields out of an object, creating a new object with just those fields. extract(file, \"ctime\", \"mtime\") = object(\"ctime\", file.ctime, \"mtime\", file.mtime) extract(object(\"test\", 1)) = object() sort(list) Sorts a list, returning a new list in sorted order. sort(list(3, 2, 1)) = list(1, 2, 3) sort(list(\"a\", \"b\", \"aa\")) = list(\"a\", \"aa\", \"b\") reverse(list) Reverses a list, returning a new list in reversed order. reverse(list(1, 2, 3)) = list(3, 2, 1) reverse(list(\"a\", \"b\", \"c\")) = list(\"c\", \"b\", \"a\") length(object|array) Returns the number of fields in an object, or the number of entries in an array. length(list()) = 0 length(list(1, 2, 3)) = 3 length(object(\"hello\", 1, \"goodbye\", 2)) = 2 sum(array) Sums all numeric values in the array sum(list(1, 2, 3)) = 6 all(array) Returns true only if ALL values in the array are truthy. You can also pass multiple arguments to this function, in which case it returns true only if all arguments are truthy. all(list(1, 2, 3)) = true all(list(true, false)) = false all(true, false) = false all(true, true, true) = true any(array) Returns true if ANY of the values in the array are truthy. You can also pass multiple arguments to this function, in which case it returns true if any of the arguments are truthy. any(list(1, 2, 3)) = true any(list(true, false)) = true any(list(false, false, false)) = false all(true, false) = true all(false, false) = false none(array) Returns true if NONE of the values in the array are truthy. none([]) = true none([false, false]) = true none([false, true]) = false none([1, 2, 3]) = false join(array) Joins elements in an array into a single string (i.e., rendering them all on the same line). If provided with a second argument, then each element will be separated by the given separator. join(list(1, 2, 3)) = \"1, 2, 3\" join(list(1, 2, 3), \" \") = \"1 2 3\" join(6) = \"6\" join(list()) = \"\" filter(array, predicate) Filters elements in an array according to the predicate, returning a new list of the elements which matched. filter([1, 2, 3], (x) => x >= 2) = [2, 3] filter([\"yes\", \"no\", \"yas\"], (x) => startswith(x, \"y\")) = [\"yes\", \"yas\"] map(array, func) Applies the function to each element in the array, returning a list of the mapped results. map([1, 2, 3], (x) => x + 2) = [3, 4, 5] map([\"yes\", \"no\"], (x) => x + \"?\") = [\"yes?\", \"no?\"] String Operations regexmatch(pattern, string) Checks if the given string matches the given pattern (using the JavaScript regex engine). regexmatch(\"\\w+\", \"hello\") = true regexmatch(\".\", \"a\") = true regexmatch(\"yes|no\", \"maybe\") = false regexreplace(string, pattern, replacement) Replaces all instances where the regex pattern matches in string , with replacement . This uses the JavaScript replace method under the hood, so you can use special characters like $1 to refer to the first capture group, and so on. regexreplace(\"yes\", \"[ys]\", \"a\") = \"aea\" regexreplace(\"Suite 1000\", \"\\d+\", \"-\") = \"Suite -\" replace(string, pattern, replacement) Replace all instances of pattern in string with replacement . replace(\"what\", \"wh\", \"h\") = \"hat\" replace(\"The big dog chased the big cat.\", \"big\", \"small\") = \"The small dog chased the small cat.\" replace(\"test\", \"test\", \"no\") = \"no\" lower(string) Convert a string to all lower case. lower(\"Test\") = \"test\" lower(\"TEST\") = \"test\" upper(string) Convert a string to all upper case. upper(\"Test\") = \"TEST\" upper(\"test\") = \"TEST\" split(string, delimiter, [limit]) Split a string on the given delimiter string. If a third argument is provided, it limits the number of splits that occur. The delimiter string is interpreted as a regular expression. If there are capture groups in the delimiter, matches are spliced into the result array, and non-matching captures are empty strings. split(\"hello world\", \" \") = list(\"hello\", \"world\") split(\"hello world\", \"\\s\") = list(\"hello\", \"world\") split(\"hello there world\", \" \", 2) = list(\"hello\", \"there\") split(\"hello there world\", \"(t?here)\") = list(\"hello \", \"there\", \" world\") split(\"hello there world\", \"( )(x)?\") = list(\"hello\", \" \", \"\", \"there\", \" \", \"\", \"world\") startswith(string, prefix) Checks if a string starts with the given prefix. startswith(\"yes\", \"ye\") = true startswith(\"path/to/something\", \"path/\") = true startswith(\"yes\", \"no\") = false endswith(string, suffix) Checks if a string ends with the given suffix. endswith(\"yes\", \"es\") = true endswith(\"path/to/something\", \"something\") = true endswith(\"yes\", \"ye\") = false padleft(string, length, [padding]) Pads a string up to the desired length by adding padding on the left side. If you omit the padding character, spaces will be used by default. padleft(\"hello\", 7) = \" hello\" padleft(\"yes\", 5, \"!\") = \"!!yes\" padright(string, length, [padding]) Equivalent to padleft , but pads to the right instead. padright(\"hello\", 7) = \"hello \" padright(\"yes\", 5, \"!\") = \"yes!!\" Utility Functions default(field, value) If field is null, return value ; otherwise return field . Useful for replacing null values with defaults. For example, to show projects which haven't been completed yet, use \"incomplete\" as their defualt value: default(dateCompleted, \"incomplete\") Default is vectorized in both arguments; if you need to use default explicitly on a list argument, use ldefault , which is the same as default but is not vectorized. default(list(1, 2, null), 3) = list(1, 2, 3) ldefault(list(1, 2, null), 3) = list(1, 2, null) choice(bool, left, right) A primitive if statement - if the first argument is truthy, returns left; otherwise, returns right. choice(true, \"yes\", \"no\") = \"yes\" choice(false, \"yes\", \"no\") = \"no\" choice(x > 4, y, z) = y if x > 4, else z striptime(date) Strip the time component of a date, leaving only the year, month, and day. Good for date comparisons if you don't care about the time. striptime(file.ctime) = file.cday striptime(file.mtime) = file.mday","title":"Functions"},{"location":"query/functions/#functions","text":"Dataview functions provide more advanced ways to manipulate data.","title":"Functions"},{"location":"query/functions/#function-vectorization","text":"Most functions can be applied either to single values (like number , string , date , etc.) OR to lists of those values. If a function is applied to a list, it also returns a list after the function is applied to each element in the list. For example: lower(\"YES\") = \"yes\" lower(list(\"YES\", \"NO\")) = list(\"yes\", \"no\") replace(\"yes\", \"e\", \"a\") = \"yas\" replace(list(\"yes\", \"ree\"), \"e\", \"a\") = list(\"yas\", \"raa\")","title":"Function Vectorization"},{"location":"query/functions/#constructors","text":"Constructors which create values.","title":"Constructors"},{"location":"query/functions/#objectkey1-value1","text":"Creates a new object with the given keys and values. Keys and values should alternate in the call, and keys should always be strings/text. object() => empty object object(\"a\", 6) => object which maps \"a\" to 6 object(\"a\", 4, \"c\", \"yes\") => object which maps a to 4, and c to \"yes\"","title":"object(key1, value1, ...)"},{"location":"query/functions/#listvalue1-value2","text":"Creates a new list with the given values in it. list() => empty list list(1, 2, 3) => list with 1, 2, and 3 list(\"a\", \"b\", \"c\") => list with \"a\", \"b\", and \"c\"","title":"list(value1, value2, ...)"},{"location":"query/functions/#dateany","text":"Parses a date from the provided string, date, or link object, if possible, returning null otherwise. date(\"2020-04-18\") = <date object representing April 18th, 2020> date([[2021-04-16]]) = <date object for the given page, refering to file.day>","title":"date(any)"},{"location":"query/functions/#numberstring","text":"Pulls the first number out of the given string, returning it if possible. Returns null if there are no numbers in the string. number(\"18 years\") = 18 number(34) = 34 number(\"hmm\") = null","title":"number(string)"},{"location":"query/functions/#stringany","text":"Converts any value into a \"reasonable\" string representation. This sometimes produces less pretty results than just directly using the value in a query - it is mostly useful for coercing dates, durations, numbers, and so on into strings for manipulation. string(18) = \"18\" string(dur(8 hours)) = \"8 hours\" string(date(2021-08-15)) = \"August 15th, 2021\"","title":"string(any)"},{"location":"query/functions/#linkpath-display","text":"Construct a link object from the given file path or name. If provided with two arguments, the second argument is the display name for the link. link(\"Hello\") => link to page named 'Hello' link(\"Hello\", \"Goodbye\") => link to page named 'Hello', displays as 'Goodbye'","title":"link(path, [display])"},{"location":"query/functions/#elinkurl-display","text":"Construct a link to an external url (like www.google.com ). If provided with two arguments, the second argument is the display name for the link. elink(\"www.google.com\") => link element to google.com elink(\"www.google.com\", \"Google\") => link element to google.com, displays as \"Google\"","title":"elink(url, [display])"},{"location":"query/functions/#numeric-operations","text":"","title":"Numeric Operations"},{"location":"query/functions/#roundnumber-digits","text":"Round a number to a given number of digits. If the second argument is not specified, rounds to the nearest whole number; otherwise, rounds to the given number of digits. round(16.555555) = 7 round(16.555555, 2) = 16.56 --","title":"round(number, [digits])"},{"location":"query/functions/#objects-arrays-and-string-operations","text":"Operations that manipulate values inside of container objects.","title":"Objects, Arrays, and String Operations"},{"location":"query/functions/#containsobjectliststring-value","text":"Checks if the given container type has the given value in it. This function behave slightly differently based on whether the first argument is an object, a list, or a string. For objects, checks if the object has a key with the given name. For example, contains(file, \"ctime\") = true contains(file, \"day\") = true (if file has a date in its title, false otherwise) For lists, checks if any of the array elements equals the given value. For example, contains(list(1, 2, 3), 3) = true contains(list(), 1) = false For strings, checks if the given value is a substring (i.e., inside) the string. contains(\"hello\", \"lo\") = true contains(\"yes\", \"no\") = false","title":"contains(object|list|string, value)"},{"location":"query/functions/#extractobject-key1-key2","text":"Pulls multiple fields out of an object, creating a new object with just those fields. extract(file, \"ctime\", \"mtime\") = object(\"ctime\", file.ctime, \"mtime\", file.mtime) extract(object(\"test\", 1)) = object()","title":"extract(object, key1, key2, ...)"},{"location":"query/functions/#sortlist","text":"Sorts a list, returning a new list in sorted order. sort(list(3, 2, 1)) = list(1, 2, 3) sort(list(\"a\", \"b\", \"aa\")) = list(\"a\", \"aa\", \"b\")","title":"sort(list)"},{"location":"query/functions/#reverselist","text":"Reverses a list, returning a new list in reversed order. reverse(list(1, 2, 3)) = list(3, 2, 1) reverse(list(\"a\", \"b\", \"c\")) = list(\"c\", \"b\", \"a\")","title":"reverse(list)"},{"location":"query/functions/#lengthobjectarray","text":"Returns the number of fields in an object, or the number of entries in an array. length(list()) = 0 length(list(1, 2, 3)) = 3 length(object(\"hello\", 1, \"goodbye\", 2)) = 2","title":"length(object|array)"},{"location":"query/functions/#sumarray","text":"Sums all numeric values in the array sum(list(1, 2, 3)) = 6","title":"sum(array)"},{"location":"query/functions/#allarray","text":"Returns true only if ALL values in the array are truthy. You can also pass multiple arguments to this function, in which case it returns true only if all arguments are truthy. all(list(1, 2, 3)) = true all(list(true, false)) = false all(true, false) = false all(true, true, true) = true","title":"all(array)"},{"location":"query/functions/#anyarray","text":"Returns true if ANY of the values in the array are truthy. You can also pass multiple arguments to this function, in which case it returns true if any of the arguments are truthy. any(list(1, 2, 3)) = true any(list(true, false)) = true any(list(false, false, false)) = false all(true, false) = true all(false, false) = false","title":"any(array)"},{"location":"query/functions/#nonearray","text":"Returns true if NONE of the values in the array are truthy. none([]) = true none([false, false]) = true none([false, true]) = false none([1, 2, 3]) = false","title":"none(array)"},{"location":"query/functions/#joinarray","text":"Joins elements in an array into a single string (i.e., rendering them all on the same line). If provided with a second argument, then each element will be separated by the given separator. join(list(1, 2, 3)) = \"1, 2, 3\" join(list(1, 2, 3), \" \") = \"1 2 3\" join(6) = \"6\" join(list()) = \"\"","title":"join(array)"},{"location":"query/functions/#filterarray-predicate","text":"Filters elements in an array according to the predicate, returning a new list of the elements which matched. filter([1, 2, 3], (x) => x >= 2) = [2, 3] filter([\"yes\", \"no\", \"yas\"], (x) => startswith(x, \"y\")) = [\"yes\", \"yas\"]","title":"filter(array, predicate)"},{"location":"query/functions/#maparray-func","text":"Applies the function to each element in the array, returning a list of the mapped results. map([1, 2, 3], (x) => x + 2) = [3, 4, 5] map([\"yes\", \"no\"], (x) => x + \"?\") = [\"yes?\", \"no?\"]","title":"map(array, func)"},{"location":"query/functions/#string-operations","text":"","title":"String Operations"},{"location":"query/functions/#regexmatchpattern-string","text":"Checks if the given string matches the given pattern (using the JavaScript regex engine). regexmatch(\"\\w+\", \"hello\") = true regexmatch(\".\", \"a\") = true regexmatch(\"yes|no\", \"maybe\") = false","title":"regexmatch(pattern, string)"},{"location":"query/functions/#regexreplacestring-pattern-replacement","text":"Replaces all instances where the regex pattern matches in string , with replacement . This uses the JavaScript replace method under the hood, so you can use special characters like $1 to refer to the first capture group, and so on. regexreplace(\"yes\", \"[ys]\", \"a\") = \"aea\" regexreplace(\"Suite 1000\", \"\\d+\", \"-\") = \"Suite -\"","title":"regexreplace(string, pattern, replacement)"},{"location":"query/functions/#replacestring-pattern-replacement","text":"Replace all instances of pattern in string with replacement . replace(\"what\", \"wh\", \"h\") = \"hat\" replace(\"The big dog chased the big cat.\", \"big\", \"small\") = \"The small dog chased the small cat.\" replace(\"test\", \"test\", \"no\") = \"no\"","title":"replace(string, pattern, replacement)"},{"location":"query/functions/#lowerstring","text":"Convert a string to all lower case. lower(\"Test\") = \"test\" lower(\"TEST\") = \"test\"","title":"lower(string)"},{"location":"query/functions/#upperstring","text":"Convert a string to all upper case. upper(\"Test\") = \"TEST\" upper(\"test\") = \"TEST\"","title":"upper(string)"},{"location":"query/functions/#splitstring-delimiter-limit","text":"Split a string on the given delimiter string. If a third argument is provided, it limits the number of splits that occur. The delimiter string is interpreted as a regular expression. If there are capture groups in the delimiter, matches are spliced into the result array, and non-matching captures are empty strings. split(\"hello world\", \" \") = list(\"hello\", \"world\") split(\"hello world\", \"\\s\") = list(\"hello\", \"world\") split(\"hello there world\", \" \", 2) = list(\"hello\", \"there\") split(\"hello there world\", \"(t?here)\") = list(\"hello \", \"there\", \" world\") split(\"hello there world\", \"( )(x)?\") = list(\"hello\", \" \", \"\", \"there\", \" \", \"\", \"world\")","title":"split(string, delimiter, [limit])"},{"location":"query/functions/#startswithstring-prefix","text":"Checks if a string starts with the given prefix. startswith(\"yes\", \"ye\") = true startswith(\"path/to/something\", \"path/\") = true startswith(\"yes\", \"no\") = false","title":"startswith(string, prefix)"},{"location":"query/functions/#endswithstring-suffix","text":"Checks if a string ends with the given suffix. endswith(\"yes\", \"es\") = true endswith(\"path/to/something\", \"something\") = true endswith(\"yes\", \"ye\") = false","title":"endswith(string, suffix)"},{"location":"query/functions/#padleftstring-length-padding","text":"Pads a string up to the desired length by adding padding on the left side. If you omit the padding character, spaces will be used by default. padleft(\"hello\", 7) = \" hello\" padleft(\"yes\", 5, \"!\") = \"!!yes\"","title":"padleft(string, length, [padding])"},{"location":"query/functions/#padrightstring-length-padding","text":"Equivalent to padleft , but pads to the right instead. padright(\"hello\", 7) = \"hello \" padright(\"yes\", 5, \"!\") = \"yes!!\"","title":"padright(string, length, [padding])"},{"location":"query/functions/#utility-functions","text":"","title":"Utility Functions"},{"location":"query/functions/#defaultfield-value","text":"If field is null, return value ; otherwise return field . Useful for replacing null values with defaults. For example, to show projects which haven't been completed yet, use \"incomplete\" as their defualt value: default(dateCompleted, \"incomplete\") Default is vectorized in both arguments; if you need to use default explicitly on a list argument, use ldefault , which is the same as default but is not vectorized. default(list(1, 2, null), 3) = list(1, 2, 3) ldefault(list(1, 2, null), 3) = list(1, 2, null)","title":"default(field, value)"},{"location":"query/functions/#choicebool-left-right","text":"A primitive if statement - if the first argument is truthy, returns left; otherwise, returns right. choice(true, \"yes\", \"no\") = \"yes\" choice(false, \"yes\", \"no\") = \"no\" choice(x > 4, y, z) = y if x > 4, else z","title":"choice(bool, left, right)"},{"location":"query/functions/#striptimedate","text":"Strip the time component of a date, leaving only the year, month, and day. Good for date comparisons if you don't care about the time. striptime(file.ctime) = file.cday striptime(file.mtime) = file.mday","title":"striptime(date)"},{"location":"query/queries/","text":"Queries The dataview query language is a simple, structured, custom query language for quickly creating views on your data. It supports: Fetching pages associated with tags, folders, links, and so on. Filtering pages / data by simple operations on fields, like comparison, existence checks, and so on. Sorting results based on fields. The query language supports the following view types, described below: TABLE : The traditional view type; one row per data point, with several columns of field data. LIST : A list of pages which match the query. You can output a single associated value for each page. TASK : A list of tasks whose pages match the given query. General Format The general format for queries is: ```dataview TABLE|LIST|TASK <field> [AS \"Column Name\"], <field>, ..., <field> FROM <source> (like #tag or \"folder\") WHERE <expression> (like 'field = value') SORT <expression> [ASC/DESC] (like 'field ASC') ... other data commands ``` Only the 'select' statement (describing what view and what fields) is required. If the FROM statement is omitted, the query runs automatically over all markdown pages in your vault. If other statements (like WHERE or SORT ) are present, they are run in the order they are written. Duplicate statements are allowed (multiple WHERE statement, for eaxmple). For the different view types, only the first line (the 'select' section, where you specify the view type and fields to display) differs. You can apply data commands like WHERE and SORT to any query, and you can select from any source using FROM . See expressions for context on what expressions are, and sources for context on what sources are. Query Types List Queries Lists are the simplest view, and simply render a list of pages (or custom fields) which match the query. To obtain a list of pages matching the query, simply use: Syntax LIST FROM <source> Query LIST FROM # games / mobas OR # games / crpg Output League of Legends Pillars of Eternity 2 You can render a single computed value in addition to each matching file, by adding an expression after LIST : Syntax LIST <expression> FROM <source> Query LIST \"File Path: \" + file . path FROM \"4. Archive\" Output 2020-12-18 DN : File path: 4. Archive/Daily Notes/2020-12-18 DN.md 2020-12-16 DN : File path: 4. Archive/Daily Notes/2020-12-16 DN.md 2020-12-17 DN : File path: 4. Archive/Daily Notes/2020-12-17 DN.md 2020-12-15 DN : File path: 4. Archive/Daily Notes/2020-12-15 DN.md LIST WITHOUT ID If you don't want the file name / group key included in the list view, you can use LIST WITHOUT ID : Syntax LIST WITHOUT ID <expression> FROM <source> Query LIST WITHOUT ID file . path FROM \"4. Archive\" Output Archive/Daily Notes/2020-12-18 DN.md Archive/Daily Notes/2020-12-16 DN.md Archive/Daily Notes/2020-12-17 DN.md Archive/Daily Notes/2020-12-15 DN.md Table Queries Tables support tabular views of page data. You construct a table by giving a comma separated list of the YAML frontmatter fields you want to render, as so: TABLE file.day, file.mtime FROM <source> You can choose a heading name to render computed fields by using the AS syntax: TABLE (file.mtime + dur(1 day)) AS next_mtime, ... FROM <source> An example table query: Query TABLE time - played AS \"Time Played\" , length AS \"Length\" , rating AS \"Rating\" FROM # game SORT rating DESC Output File Time Played Length Rating Outer Wilds November 19th - 21st, 2020 15h 9.5 Minecraft All the time. 2000h 9.5 Pillars of Eternity 2 August - October 2019 100h 9 TABLE WITHOUT ID If you don't want the default \"File\" or \"Group\" field in your output (either to replace it or because it is unneeded), you can use TABLE WITHOUT ID : Query TABLE WITHOUT ID time - played AS \"Time Played\" , length AS \"Length\" , rating AS \"Rating\" FROM # game SORT rating DESC Output Time Played Length Rating November 19th - 21st, 2020 15h 9.5 All the time. 2000h 9.5 August - October 2019 100h 9 Task Queries Task views render all tasks whose pages match the given predicate. Syntax TASK FROM <source> Query TASK FROM \"dataview\" Output dataview/Project A I am a task. I am another task. dataview/Project A I could be a task, though who knows. Determine if this is a task. I'm a finished task. You can filter ( WHERE ), group ( GROUP BY ), sort ( SORT ) tasks in these queries as desired using typical dataview statements: Syntax TASK FROM <source> WHERE <predicate> ... Query TASK FROM \"dataview\" WHERE !completed GROUP BY file.folder Output Folder 1 I am a task. I am another task. I am yet another task in another file in the same folder. Folder 2 I could be a task, though who knows. Folder 3 What even is a task, anyway? Data Commands The different commands that dataview queries can be made up of. Commands are executed in order, and you can have duplicate commands (so multiple WHERE blocks or multiple GROUP BY blocks, for example). FROM The FROM statement determines what pages will initially be collected and passed onto the other commands for further filtering. You can select from any source , which currently means by folder, by tag, or by incoming/outgoing links. Tags : To select from a tag (and all its subtags), use FROM #tag . Folders : To select from a folder (and all its subfolders), use FROM \"folder\" . Links : You can either select links TO a file, or all links FROM a file. To obtain all pages which link TO [[note]] , use FROM [[note]] . To obtain all pages which link FROM [[note]] (i.e., all the links in that file), use FROM outgoing([[note]]) . You can compose these filters in order to get more advanced sources using and and or . For example, #tag and \"folder\" will return all pages in folder and with #tag . [[Food]] or [[Exercise]] will give any pages which link to [[Food]] OR [[Exercise]] . You can also \"negate\" sources to obtain anything that does NOT match a source using - : -#tag will exclude files which have the given tag. #tag and -\"folder\" will only include files tagged #tag which are NOT in \"folder\" . WHERE Filter pages on fields. Only pages where the clause evaluates to true will be yielded. WHERE <clause> Obtain all files which were modified in the last 24 hours: LIST WHERE file . mtime >= date ( today ) - dur ( 1 day ) Find all projects which are not marked complete and are more than a month old: LIST FROM # projects WHERE ! completed AND file . ctime <= date ( today ) - dur ( 1 month ) SORT Sorts all results by one or more fields. SORT date [ASCENDING/DESCENDING/ASC/DESC] You can also give multiple fields to sort by. Sorting will be done based on the first field. Then, if a tie occurs, the second field will be used to sort the tied fields. If there is still a tie, the third sort will resolve it, and so on. SORT field1 [ASCENDING/DESCENDING/ASC/DESC], ..., fieldN [ASC/DESC] GROUP BY Group all results on a field. Yields one row per unique field value, which has 2 properties: one corresponding to the field being grouped on, and a rows array field which contains all of the pages that matched. GROUP BY field GROUP BY (computed_field) AS name In order to make working with the rows array easier, Dataview supports field \"swizzling\". If you want the field test from every object in the rows array, then rows.test will automatically fetch the test field from every object in rows , yielding a new array. You can then apply aggregation operators like sum() over the resulting array. FLATTEN Flatten an array in every row, yielding one result row per entry in the array. FLATTEN field FLATTEN (computed_field) AS name For example, flatten the authors field in each literature note to give one row per author: Query TABLE authors FROM # LiteratureNote FLATTEN authors Output File authors stegEnvironmentalPsychologyIntroduction2018 SN Steg, L. stegEnvironmentalPsychologyIntroduction2018 SN Van den Berg, A. E. stegEnvironmentalPsychologyIntroduction2018 SN De Groot, J. I. M. Soap Dragons SN Robert Lamb Soap Dragons SN Joe McCormick smithPainAssaultSelf2007 SN Jonathan A. Smith smithPainAssaultSelf2007 SN Mike Osborn","title":"Queries"},{"location":"query/queries/#queries","text":"The dataview query language is a simple, structured, custom query language for quickly creating views on your data. It supports: Fetching pages associated with tags, folders, links, and so on. Filtering pages / data by simple operations on fields, like comparison, existence checks, and so on. Sorting results based on fields. The query language supports the following view types, described below: TABLE : The traditional view type; one row per data point, with several columns of field data. LIST : A list of pages which match the query. You can output a single associated value for each page. TASK : A list of tasks whose pages match the given query.","title":"Queries"},{"location":"query/queries/#general-format","text":"The general format for queries is: ```dataview TABLE|LIST|TASK <field> [AS \"Column Name\"], <field>, ..., <field> FROM <source> (like #tag or \"folder\") WHERE <expression> (like 'field = value') SORT <expression> [ASC/DESC] (like 'field ASC') ... other data commands ``` Only the 'select' statement (describing what view and what fields) is required. If the FROM statement is omitted, the query runs automatically over all markdown pages in your vault. If other statements (like WHERE or SORT ) are present, they are run in the order they are written. Duplicate statements are allowed (multiple WHERE statement, for eaxmple). For the different view types, only the first line (the 'select' section, where you specify the view type and fields to display) differs. You can apply data commands like WHERE and SORT to any query, and you can select from any source using FROM . See expressions for context on what expressions are, and sources for context on what sources are.","title":"General Format"},{"location":"query/queries/#query-types","text":"","title":"Query Types"},{"location":"query/queries/#list-queries","text":"Lists are the simplest view, and simply render a list of pages (or custom fields) which match the query. To obtain a list of pages matching the query, simply use: Syntax LIST FROM <source> Query LIST FROM # games / mobas OR # games / crpg Output League of Legends Pillars of Eternity 2 You can render a single computed value in addition to each matching file, by adding an expression after LIST : Syntax LIST <expression> FROM <source> Query LIST \"File Path: \" + file . path FROM \"4. Archive\" Output 2020-12-18 DN : File path: 4. Archive/Daily Notes/2020-12-18 DN.md 2020-12-16 DN : File path: 4. Archive/Daily Notes/2020-12-16 DN.md 2020-12-17 DN : File path: 4. Archive/Daily Notes/2020-12-17 DN.md 2020-12-15 DN : File path: 4. Archive/Daily Notes/2020-12-15 DN.md","title":"List Queries"},{"location":"query/queries/#list-without-id","text":"If you don't want the file name / group key included in the list view, you can use LIST WITHOUT ID : Syntax LIST WITHOUT ID <expression> FROM <source> Query LIST WITHOUT ID file . path FROM \"4. Archive\" Output Archive/Daily Notes/2020-12-18 DN.md Archive/Daily Notes/2020-12-16 DN.md Archive/Daily Notes/2020-12-17 DN.md Archive/Daily Notes/2020-12-15 DN.md","title":"LIST WITHOUT ID"},{"location":"query/queries/#table-queries","text":"Tables support tabular views of page data. You construct a table by giving a comma separated list of the YAML frontmatter fields you want to render, as so: TABLE file.day, file.mtime FROM <source> You can choose a heading name to render computed fields by using the AS syntax: TABLE (file.mtime + dur(1 day)) AS next_mtime, ... FROM <source> An example table query: Query TABLE time - played AS \"Time Played\" , length AS \"Length\" , rating AS \"Rating\" FROM # game SORT rating DESC Output File Time Played Length Rating Outer Wilds November 19th - 21st, 2020 15h 9.5 Minecraft All the time. 2000h 9.5 Pillars of Eternity 2 August - October 2019 100h 9","title":"Table Queries"},{"location":"query/queries/#table-without-id","text":"If you don't want the default \"File\" or \"Group\" field in your output (either to replace it or because it is unneeded), you can use TABLE WITHOUT ID : Query TABLE WITHOUT ID time - played AS \"Time Played\" , length AS \"Length\" , rating AS \"Rating\" FROM # game SORT rating DESC Output Time Played Length Rating November 19th - 21st, 2020 15h 9.5 All the time. 2000h 9.5 August - October 2019 100h 9","title":"TABLE WITHOUT ID"},{"location":"query/queries/#task-queries","text":"Task views render all tasks whose pages match the given predicate. Syntax TASK FROM <source> Query TASK FROM \"dataview\" Output dataview/Project A I am a task. I am another task. dataview/Project A I could be a task, though who knows. Determine if this is a task. I'm a finished task. You can filter ( WHERE ), group ( GROUP BY ), sort ( SORT ) tasks in these queries as desired using typical dataview statements: Syntax TASK FROM <source> WHERE <predicate> ... Query TASK FROM \"dataview\" WHERE !completed GROUP BY file.folder Output Folder 1 I am a task. I am another task. I am yet another task in another file in the same folder. Folder 2 I could be a task, though who knows. Folder 3 What even is a task, anyway?","title":"Task Queries"},{"location":"query/queries/#data-commands","text":"The different commands that dataview queries can be made up of. Commands are executed in order, and you can have duplicate commands (so multiple WHERE blocks or multiple GROUP BY blocks, for example).","title":"Data Commands"},{"location":"query/queries/#from","text":"The FROM statement determines what pages will initially be collected and passed onto the other commands for further filtering. You can select from any source , which currently means by folder, by tag, or by incoming/outgoing links. Tags : To select from a tag (and all its subtags), use FROM #tag . Folders : To select from a folder (and all its subfolders), use FROM \"folder\" . Links : You can either select links TO a file, or all links FROM a file. To obtain all pages which link TO [[note]] , use FROM [[note]] . To obtain all pages which link FROM [[note]] (i.e., all the links in that file), use FROM outgoing([[note]]) . You can compose these filters in order to get more advanced sources using and and or . For example, #tag and \"folder\" will return all pages in folder and with #tag . [[Food]] or [[Exercise]] will give any pages which link to [[Food]] OR [[Exercise]] . You can also \"negate\" sources to obtain anything that does NOT match a source using - : -#tag will exclude files which have the given tag. #tag and -\"folder\" will only include files tagged #tag which are NOT in \"folder\" .","title":"FROM"},{"location":"query/queries/#where","text":"Filter pages on fields. Only pages where the clause evaluates to true will be yielded. WHERE <clause> Obtain all files which were modified in the last 24 hours: LIST WHERE file . mtime >= date ( today ) - dur ( 1 day ) Find all projects which are not marked complete and are more than a month old: LIST FROM # projects WHERE ! completed AND file . ctime <= date ( today ) - dur ( 1 month )","title":"WHERE"},{"location":"query/queries/#sort","text":"Sorts all results by one or more fields. SORT date [ASCENDING/DESCENDING/ASC/DESC] You can also give multiple fields to sort by. Sorting will be done based on the first field. Then, if a tie occurs, the second field will be used to sort the tied fields. If there is still a tie, the third sort will resolve it, and so on. SORT field1 [ASCENDING/DESCENDING/ASC/DESC], ..., fieldN [ASC/DESC]","title":"SORT"},{"location":"query/queries/#group-by","text":"Group all results on a field. Yields one row per unique field value, which has 2 properties: one corresponding to the field being grouped on, and a rows array field which contains all of the pages that matched. GROUP BY field GROUP BY (computed_field) AS name In order to make working with the rows array easier, Dataview supports field \"swizzling\". If you want the field test from every object in the rows array, then rows.test will automatically fetch the test field from every object in rows , yielding a new array. You can then apply aggregation operators like sum() over the resulting array.","title":"GROUP BY"},{"location":"query/queries/#flatten","text":"Flatten an array in every row, yielding one result row per entry in the array. FLATTEN field FLATTEN (computed_field) AS name For example, flatten the authors field in each literature note to give one row per author: Query TABLE authors FROM # LiteratureNote FLATTEN authors Output File authors stegEnvironmentalPsychologyIntroduction2018 SN Steg, L. stegEnvironmentalPsychologyIntroduction2018 SN Van den Berg, A. E. stegEnvironmentalPsychologyIntroduction2018 SN De Groot, J. I. M. Soap Dragons SN Robert Lamb Soap Dragons SN Joe McCormick smithPainAssaultSelf2007 SN Jonathan A. Smith smithPainAssaultSelf2007 SN Mike Osborn","title":"FLATTEN"},{"location":"query/sources/","text":"Sources A dataview \"source\" is something that identifies a set of files, tasks, or other data object. Sources are indexed internally by Dataview, so they are fast to query. Dataview currently supports three source types: Tags : Sources of the form #tag . Folders : Sources of the form \"folder\" . Specific Files : You can select from a specific file by specifying it's full path: \"folder/File\" . If you have both a file and a folder with the exact same path, Dataview will prefer the folder. You can force it to read from the file by specifying markdown: folder/File.md . Links : You can either select links TO a file, or all links FROM a file. To obtain all pages which link TO [[note]] , use [[note]] . To obtain all pages which link FROM [[note]] (i.e., all the links in that file), use outgoing([[note]]) . You can compose these filters in order to get more advanced sources using and and or . For example, #tag and \"folder\" will return all pages in folder and with #tag . Querying from #food and !#fastfood will only return pages that contain #food but does not contain #fastfood . [[Food]] or [[Exercise]] will give any pages which link to [[Food]] OR [[Exercise]] . Sources are used in both the FROM query statement , as well as various JavaScript API query calls.","title":"Sources"},{"location":"query/sources/#sources","text":"A dataview \"source\" is something that identifies a set of files, tasks, or other data object. Sources are indexed internally by Dataview, so they are fast to query. Dataview currently supports three source types: Tags : Sources of the form #tag . Folders : Sources of the form \"folder\" . Specific Files : You can select from a specific file by specifying it's full path: \"folder/File\" . If you have both a file and a folder with the exact same path, Dataview will prefer the folder. You can force it to read from the file by specifying markdown: folder/File.md . Links : You can either select links TO a file, or all links FROM a file. To obtain all pages which link TO [[note]] , use [[note]] . To obtain all pages which link FROM [[note]] (i.e., all the links in that file), use outgoing([[note]]) . You can compose these filters in order to get more advanced sources using and and or . For example, #tag and \"folder\" will return all pages in folder and with #tag . Querying from #food and !#fastfood will only return pages that contain #food but does not contain #fastfood . [[Food]] or [[Exercise]] will give any pages which link to [[Food]] OR [[Exercise]] . Sources are used in both the FROM query statement , as well as various JavaScript API query calls.","title":"Sources"}]}